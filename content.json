{"pages":[],"posts":[{"title":"JPA Entity Annotation 정리","text":"본 내용은 자바 ORM 표준 JPA 프로그래임 (김영환 지음)을 참고하였음. Requirements Springboot 2.2.4.RELEASE Gradle 6.0.1 Dependencies(implementation) org.springframework.boot:spring-boot-starter-data-jpa org.springframework.boot:spring-boot-starter-web org.springframework.boot:spring-boot-starter-data-jdbc Dependencies(compileOnly) org.projectlombok:lombok Dependencies(runtimeOnly) com.oracle.ojdbc:ojdbc8 Dependencies(testCompile) junit:junit:4.12 DBMS Oracle Database 11g Standard Edition One(se1) Entity 맵핑에 있어 XML을 이용한 외부에서의 설정 방식과 Annotation을 이용한 내부에서의 설정 방식이 있다.이중 사용이 간편하고 상대방이 보기에도 코드가 직관적인 장점을 지닌 Annotation방식을 이용하며,다양한 상황에 따른 테이블의 제약조건을 가정하여 매핑 작업에 활용된 Annotation을 정리한다. 목차 객체와 테이블 매핑 @Entity @Table 기본 키 매핑 직접할당 자동생성(Sequence전략) 필드와 컬럼 매핑 @Column 연관관계 매핑 @ManyToOne @JoinColumn 본문1. 객체와 테이블 매핑annotation entityJPA를 사용하는 경우 DB 테이블과 매핑될 클래스는 @Entity가 붙는다. 이는 JPA 프레임워크에서 관리하며 다음과 같은 주의 사항이 있다. 기본 생성자는 필수(public 또는 protected) final 클래스 같은 상수와 추상객체인 enum,interface,inner 클래스에는 사용 불가. 맵핑할 객체에 final은 사용할 수 없다. 기본 생성자가 없는 경우 아래와 같이 ‘JpaSystemException’ 에러가 발생하며 ‘No default constructor for entity’ 의 메시지로사용자에게 기본 생성자가 선언되지 않았음을 알리고 있다. annotation tableEntity 오브젝트와 매핑할 DB의 테이블 명을 지정한다. 각 속성은 아래와 같다. uniqueConstraints DDL생성 시 Entity 오브젝트에서 복수개의 unique 제약조건을 지정하기 위해 사용된다. 각각의 uniqueConstraints의 지정된 값은 @Column의 name속성 값을 따른다. unique column은 각 속성, name과 columnNames로 구성되며 name의 경우 DDL을 DBMS에 전달하여 해당 내용으로 unique index를 생성한다. indexes RDBMS의 대용량 데이터를 관리하는 경우 검색 속도를 높히기 위한 작업이다. 생성된 Table의 Column에 색인을 지정하여 따로 색인정보가 담긴 파일을 생성하고 select 요청 시 해당 Table을 전체 스캔하는 것이 아닌 색인화 된 Index 파일을 검색한다. Oracle의 경우 색인 알고리즘인 B-tree(binary search tree)를 적용하고 있다. Entity Mapping에서 사용된 @Index의 속성값 name은 색인 검색을 위한 파일 명, columnList는 색인을 위한 Column name이다. catalog 맵핑할 DB catalog를 매핑한다. schema schema를 매핑한다. name 맵핑할 DB table 이름을 지정한다.1@Table(name = &quot;MY_FAVOLITE&quot;) 2. 기본 키 매핑직접할당Database의 Row Column 값을 구분을 위한 기본키(Primary Key)를 직접 할당한다. 123@Id@Column(name = &quot;ID&quot;)private long id; 자동생성대리키(Alternate key)를 사용한 방식. JPA에서의 기본키 생성 전략 은 다음과 같다. IDENTITY 전락 : 기본키 생성을 데이터베이스에 위임하여 관리한다 (MySQL, PostgreSQL 등) TABLE 전략 : 키 생성을 위한 테이블을 하나 만들고 이름과 값으로 컬럼을 만들어 데이터베이스 Sequence를 흉내낸다. SEQUENCE 전략 : 데이터베이스의 Sequence는 Unique 값을 순서대로 저장하는 하나의 오브젝트이다. JPA에선 Entity에 @SequenceGenerator를 선언하여 관리한다. *본 절에선 Oracle을 사용한 Sequence 전략을 다뤘음. annotation SequenceGenerator3. 필드와 컬럼 매핑annotation column4. 연관관계 매핑annotation many to oneannotation join column","link":"/2020/02/17/JPA-Entity/"},{"title":"SpringBoot Netty 서버에 SSL 적용기 1","text":"개요본 포스팅 내용은 Google Cloud Platform의 가상머신을 통해 SpringBoot-Framework가 적용된 Web Application Server이며, 자신이 소유한 도메인이 있는 것으로 가정하고소유한 도메인을 자신의 가상컴퓨팅에 맵핑하는 과정을 정리했다. 설치가 되어 있다는 가정하에 진행한다. 준비 openSSL 라이브러리( sslforfree에서 제공해준 서명된 인증파일을 JavaKeyStore(jks)로 변환하기 위해 필요.) 도메인 ( https:// 접근을 위해 필요하다. ) 도베인적용DNS 영역 설정SpringBoot Netty서버 gradle환경에서 배포하기에서 배포한SpringBoot Netty서버에 자신의 도메인을 등록한다. 컴퓨팅환경은 Google Cloud Platform 을 통해 배포되었다.다음 예제에서 DNS와 연결할 컴퓨팅환경은 다음과 같다. 네트워크 서비스 - Cloud DNS - 영역만들기 영역이름 : 해당 DNS 영역의 이름 DNS이름 : 자신이 구매한 DNS의 이름 영역 세부정보DNS 도메인의 레코드를 설정한다. ‘레코드 모음 추가’를 선택한다. 기본적인 입력정보는 다음과 같다. A (Address Mapping records) : 도메인에 호스트의 IP주소(설정한외부IP)를 알려준다. 도메인과 IP주소의 맵핑작업이다.도메인주소 -&gt; IP주소 CNAME (Canonical Name) : 도메인을 따로 지정한 임의 도메인과 맵핑한다.임의도메인주소 -&gt; 도메인주소 NS (Name Server) : 해당 호스트의 공식 이름 서버이다. SOA (Start of Authority) : DNS서버의 설정정보가 담겨있다. DNS 네임서버 설정구매한 자신의 도메인의 네임서버를 설정한다.아래는 GoDaddy에서 구매한 도메인의 네임서버를 입력해 주는 장면이다. Google Cloud Platform의 자신의 DNS레코드에 생성된NS (Name Server)의 값을 모두 넣어준다. 앞에 ‘.’ 이 붙어있는데 이는 오류를 불러온다 지우자. DNS 레코드 맵핑 확인A (Address Mapping records)에 맵핑된 도메인정보와 IP주소가 올바른지 확인한다. 1nslookup 도메인주소 도메인 접속해보기 psGoddy를 통해 도메인을 구입했다. 해당 DNS 네임서버에 내 GCP서버의 갱신하는데 있어 약 10~15분 걸린거같다.","link":"/2019/07/29/SpringBoot-Netty-%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%E1%84%8B%E1%85%A6-SSL-%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%B5/"},{"title":"오픈소스 기반의 자율주행 시뮬레이터 Carla를 활용한 시스템 개발기","text":"Project 실세계 정보를 반영한 오픈소스 기반의 자율주행 시뮬레이션 시스템 설계 및 구현 Prerequirements Python3.8 Carla-Simulator 0.9.9.4 PyCharm Python Package Index(PyPI) Future Numpy Pygame Network PyQt5 Project link https://github.com/Kimbaro/carlaAPI_Based.git (Git) https://github.com/Kimbaro/carlaAPI_Based.git -b 2020-12-08 Carla Document https://carla.readthedocs.io/en/0.9.9/ 들어가기 앞서Carla Document에 신규 맵 생성에 관한 내용이 삭제/변경됨에 따라 RoadRunner를 통한 생성 방법만 명시하고 있어 기존 신규 맵 생성에 관한 내용을 공유함. OpenDRIVE 적용 FBX 적용 Intro과제내용최근 자율주행을 위한 기술개발 과정에서 실세계의 다양한 학습데이터를 활용한 딥러닝 기술이 활발히 이용되고 있다. 그러나 자율주행 알고리즘의 성능에 핵심적인 역할을 하는 날씨, 도로환경, 교통정보 등의 다양하게 변화하는 상황을 반영하기 위한 학습데이터 수집 과정은 다양한 시공간적 한계가 발생하게 된다.또한 학습 데이터 수집을 위한 Camera, Lidar, GPS 등 고성능의 센서도 함께 요구되며 이에 따른 고비용의 센서의 활용 측면에서도 고려하지 않을 수 없다.다양한 상황을 반영하는 학습데이터 수집에 있어서 이러한 과정들은 엄청난 비용 및 시간이 소요되는 문제가 발생할 뿐더러 실세계에서 다양한 시나리오 속 자율주행 차량의 학습 데이터 수집 과정에서도 주행 중의 안정적인 측면 또한 고려해야 한다. 이에 본 연구에서는 기존의 고정밀 공간정보를 이용하여 실세계를 모사한 가상환경 기반의 자율주행 시뮬레이션 시스템을 설계 및 구현하고자 한다.개발되는 시스템은 시공간적 한계를 극복하고 비용 및 시간 효율적으로 다양한 상황의 자율주행을 위한 학습데이터를 수집할 수 있을 것으로 기대된다.구체적으로 가상환경은 브이월드의 3차원 공간정보와 국토지리정보원 정밀도로지도를 융합하여 구축하며, 자율주행 시뮬레이션 시스템은 CARLA의 오픈소스를 확장하여 설계 및 구현한다.이를 기반으로 학습데이터 수집을 위한 차량인 Data Collection Vehicle(DCV)를 타겟으로 컴퓨터 스스로 목적지를 판별하는 목적지자율주행이나 클라이언트가 선정한 임의 목적지를 주행하는 목적지임의주행을 제공하며 주행 차량의 운전 성향을 설정하여 공격적이거나 방어적인 운전을 수행하고 차량을 추월하거나 신호를 무시하는 행동을 취할 수 있다.데이터 수집을 위한 센서 활용에 있어서 가상환경의 특성상 탈부착이나 고장의 발생 등 여러 고려해야할 상황으로 부터 자유롭다. 실세계 주행환경을 반영하여 시공간적 제약을 받는 날씨, 도로환경, 교통정보를 자유롭게 반영할 수도 있다.학습데이터 수집 뿐만 아니라 실세계 신호체계를 반영하여 교통정보를 모니터링도 가능하다. 본 연구에서는 실세계 정밀도로지도를 반영한 가상환경에서의 데이터 수집과 차량 주행을 수행하는 시스템을 설계하고 구현한 내용을 소개한다 관련기술 Technology Companies Waymo (Google) Google-Brain과의 공동프로젝트로 이미지 데이터와 라이다 데이터를 활용해 해당 카메라 시점에서의 물체의 깊이를 예측할 수 있는 ViDAR를 발표하였다. Uber 자율주행 환경에서 무선 네트워크에 연결된 자율주행 차량 간 데이터셋과 타임 스탬프 및 위치정보를 포함한 정보 교환으로 라이더 센서의 인식률을 높힌 V2VNET 기술을 발표하였다. NVIDIA DRIVE sim 소프트웨어로 가상환경에서의 학습데이터 수집과 실세계에서의 학습데이터를 수집하여 두 환경에서의 3차원 맵핑으로 실제 환경에서 주행하는 듯한 환경을 구성하여 센서 데이터를 수집한다. Open Source Simulations and/or Providers CARLA 자율주행을 위한 오픈소스 기반의 시뮬레이터로 Intel Labs, Toyota Research Institude 등 업체와 연계하고 있다. 차량 인식과 제어 등 다양한 테스트가 가능하다. Microsoft AirSim 드론, 자동차 등을 위한 환경으로 오픈소스 기반의 시뮬레이터 이다. 자율주행을 위한 딥러닝의 강화학습을 수행할 수 있다. 본문(1)(정밀도로지도변환) NGII HD Map -&gt; OpenDRIVE 변환 및 적용 시연(여의도) 기존정밀도로지도 분석 및 변환내용본 제안된 시스템의 실세계 모사한 환경은 국토지리정보원의 수집된 정밀도로지도 데이터와 브이월드의 3차원 입체모형을 반영하여 가상환경을 구성한다.국토지리정보원의 정밀도로지도는 ESRI ShapeFile 형태의 포멧으로 구성된다. 본 제공된 ShapeFile은 .shp, .shx, .dbf 형식의 데이터로 이뤄져 있다. .shp(shape format)파일은 벡터형식의 도형정보를 표현하며 정밀도로지도에서는 도로를 도형으로써 폴리곤을 정의하고 있으며 해당 도형의 좌표 데이터를 포함한다. .shx(shape index format)파일은 .shp에 정의된 도로 레이어의 정보를 담고 있다. .dbf파일은 도로의 속성정보를 담고 있으며 dBase형식을 사용한다. 이러한 형식은 전체 도로를 구성하는 각 레이어를 중심으로한 비계층적 구조이며 Bottom-Up 방식으로 정의되어 있다.본 제안된 시스템에서 활용된 자율주행 시뮬레이션 플랫폼은 국토지리정보원에서 제공된 ESRI ShapeFile 포멧이 아닌 산업계 표준 데이터 모델인 OpenDRIVE 형태의 포멧을 요구한다.해당 포멧은 계층적 구조를 가지며 도로 또는 시설물에 대해 Top-Down 방식으로 이뤄져있다. 이러한 방식은 도로중심선(ReferenceLine)을 기준으로 차로, 교차로 및 주변 시설물로 정의된다. 데이터는 XML 형식으로 구성된다. 정밀도로지도 데이터와 OpenDRIVE는 계층적 구조가 다른 문제점이 발생하며 아울러 표현 대상 및 구조적 속성, 형식등 상이하는 문제가 발생하게 된다.때문에 두 데이터 모델은 상호 불일치하거나 데이터의 항목이 일치하더라도 세부적으로 서로 다른 문제가 발생하며 이러한 문제로 인하여 상호 호환 및 변환을 위한 추가적인 작업 및 데이터 가공 작업이 상당히 필요함을 알 수 있다.국토지리정보원의 데이터 모델은 아래와 같이 기존 네비게이션 지도에서 활용되었던 노드-링크 체계 개념을 각 차로 별로 확장하여 차로 및 도로 시설물 들을 표현 할 수 있는 14개의 레이어로 정의한다.여기서 객체 중심의 계층적으로 정의된 OpenDRIVE와 개별 레이어로 정의된 국토지리정보원의 데이터 모델간의 많은 차이로 인하여 상호 호환 및 변환 과정에서 다양한 문제가 발생한다. 첫째 국토지리정보원의 정밀도로지도 데이터는 도로중심선(Reference Line)이 정의되어 있지 않아 OpenDRIVE 형식으로 변환 하기 어려운 문제가 발생한다. 둘째 개별 차로의 표현과 관련해서도 OpenDRIVE는 차로 폭을 포함하는 세부정보 등을 정의하고 있으나 국토지리정보원의 데이터는 차로 중심선만을 정의하고 있으며 부실한 세부정보로 인해 교차로의 구분이 모호하다. 또한 각 도로의 차선 폭 데이터가 존재하지 않아 국토지리정보원의 정밀도로지도에서 특수 추가차선(좌회전 전용, 유턴전용 등)의 차선번호 지정방식과 OpenDRIVE방식과의 차이가 존재했다. 셋째 OpenDRIVE는 도로와 교차로를 구분하여 교차로의 세부적인 표현을 위한 Junction 객체를 별도로 정의하고 있으나 국토지리정보원의 데이터는 교차로 정보에 대해서도 노드-링크 체계로 이뤄져 있어 각각을 검색해 추출해야하는 문제점이 발생한다. 넷째 OpenDRIVE는 곡선 형태의 도로표현을 지원하고 있어 자유롭게 도로의 꺾임 정도를 표현할 수 있다. 하지만 국토지리정보원의 데이터는 이를 지원하지 않아 곡선 형태의 도로를 노드-링크 체계의 여러개의 직선도로로 연결하여 표현해야한다. 본 연구에서는 아래 표와 같이 데이터 변환을 위하여 NGII HD Map의 개별 레이어들을 OpenDRIVE 객체로 간략히 매핑하였다. 아울러 이러한 매핑 과정에서 위에서 언급된 네 가지 문제를 해결할 수 있는 데이터 변환 방안을 제안하고 있다. 첫째 구체적으로 NGII HD Map의 도로중심과 가장 유사한 레이어를 선택하여 OpenDRIVE의 도로중심선(ReferenceLine)을 생성한다. 이러한 과정은 다음과 같이 도로 중심선에서 가장 가까운 지점에 위치한 양방향의 A2_LINK의 차로정보를 검색한다 둘째 차로 폭 문제는 실측된 정밀도로지도 데이터와 완전히 일치하지 않을 수 있지만, 국토부 법령에서 정한 3m 또는 3.25m를 이용하여 일률적으로 지정하였다. 셋째 세부적인 교차로내의 회전 정보 및 도로 연결 정보 등의 표현 문제는 NGII HD Map에서 교차로를 의미하는 속성정보를 이용하여 이와 연결되는 차로의 A2_LINK를 모두 찾아서 정보를 입력하였다. 넷째 아래의 그림은 여의도 지역의 NGII HD Map으로부터 OpenDRIVE의 ReferenceLine을 추출한 예제를 보여준다. 본문(2)(시스템개발) 시스템 주행환경 제어 시연 CARLA의 오픈소스 기반 자율주행 시뮬레이션 제어 시스템 설계 및 구현 CARLA는 Unreal Engine에서 OpenDRIVE의 XODR 포맷과 Autodesk MotionBuilder의 FBX 포맷을 사용함 XODR은 road network 정보를 가진 포맷으로 XML로부터 확장되고 계층 구조를 가짐 FBX는 2D 또는 3D 객체 및 콘텐츠 정보 표현을 위한 포맷으로 3D 응용 프로그램임 실세계 3D 도시모델 CARLA 시뮬레이션 맵에 가시화 방법 브이월드에서 제공되는 FBX 형태의 3차원 건물 입체모형을 CARLA 3D 도시모델 데이터로 Import 함 국토지리정보원에서 제공되는 정밀도로지도 데이터(GIS ShapeFile)의 Converting Module을 개발하여 이를 활용해 OpenDrive Format 데이터 생성 및 Import 함 본 시스템은 Simulation을 위한 서버와 제어 및 접근을 위한 클라이언트로 나뉨. Simulation 3차원 도시모델을 생성하기 위해 UE4의 import static mesh 옵션을 적용하여 3차원 도시모델 데이터를 가상환경에 배치함 generate routes 옵션으로는 CARLA UE4에서 OpenDRIVE에 정의된 도로네트워크를 구성하기 위해 제공된 Plugin임 Client 가상환경 내 발생한 모든 동적 오브젝트의 정보를 RPC 프로토콜을 활용해 서버와 연결된 모든 사용자들과 이벤트 정보를 동기화함 자율주행에 필요한 센서, 교통정보, 차량이벤트 같은 API와 RPC 프로토콜이 포함된 패키지에 의존하여 기능이 구현됨 Sensor API로는 실세계 자율주행에 필요한 지능형운전자보조시스템(ADAS, Advanced Drive Assistance)의 기능을 수행하기 위한 대부분의 센서들이 제공됨 Traffic API는 신호등제어, 교통흐름제어, 사고제어 상황을 구현하기 위한 기능을 제공함 Vehicle Event API의 경우 충돌, 차선변경, 장애물감지 등 상황 구현을 위한 기능으로 자율주행 차량의 주행과정에 있어 발생한 이벤트 정보가 반환됨 CARLA는 총 4개의 Core concept으로 분류할 수 있음 World and client World는 actor 생성, 날씨 변화 등 시뮬레이션 환경의 전반에 대한 API를 포함하고 있음. client는 Server(Simulation)에 접근하여 환경정보 및 개체제어를 요청할수 있음 TCP/UDP방식의 연결로 RPC library를 통한 API 호출로 시뮬레이션 제어를 요청할 수 있음 Actors and blueprints 가상환경에 오브젝트를 생성하기 위해선 아래의 이미지와 같은 구조의 블루프린트를 자유롭게 읽어올 수 있어야함 구성은 List 타입의 BlueprintLibrary와 ActorBlueprint인자의 모음으로 볼 수 있음 Actor의 종류에 따라 할당되는 ActorBlueprint 속성이 다름 Maps and navigation Map은 3D 도시모델 FBX와 OpenDRIVE Standard 1.4 기반의 데이터를 바인딩하며 본 연구에서는 Python Class에서 해당 정보를 참조함 가상환경내 위치정보와 주행경로생성, 보행자 및 차량 생성 등 위한 위치정보는 Waypoint 객체를 통해 얻어옴 Waypoint는 차선 및 도로정보를 알 수 있음 transform은 Waypoint에 포함된 객체이며 3D Actor들의 위치, 방향에 대한 정보를 담고 있음 Sensors and data 센서는 데이터를 측정하고 송출할 수 있는 Actor임 일반적으로 차량에 부착되고, 시뮬레이션의 FPS에 따라 센서 정보가 업데이트되며 클라이언트는 해당 센서 정보를 PythonAPI를 통해 동기화함 차량의 차선변경이나 충돌 등을 감지하기 위한 근접센서, Camera의 이미지 수집 센서, 주행 중 물체를 감지하기 위한 Radar, LIDAR 센서들에 대한 시뮬레이션 기능을 위한 API를 제공 설계 본 연구의 시스템을 개발하기 위해 위과 같이 시퀀스모델을 작성하였다.Traffic API를 활용해 대상 차량의 주행 기능을 구현하기 위한 부분과 Sensor API를 활용해 대상 차량에 개수와 상관없이 자유롭게 센서를 생성하고 부착하며 그 외에 Weather와 NPC를 Spawn하기 위한 API를 활용한다.이는 자율주행 학습데이터를 수집하기 위해 다양한 날씨와 같은 환경구성과 도로의 표면을 설정하고 주행 환경을 위해 보행자와 여러 차량을 생성하기 위한 목적을 가진다.환경을 구성하는 등 변화를 주는 경우 세부적으로 비의 강도, 물 웅덩이, 바람의 강도를 설정할 수 있게된다. User는 Run-Time Module로 start_module.py을 실행한다.실행 모듈은 Multi-Threading 방식으로 동작하여 크게 두 가지 항목으로 분류된다. Driving module은 Data Collection Vehicle(DCV)를 생성하고 해당 차량의 BP(Blueprint)의 속성(Attribute)를 설정한다. 본 시스템은 BP의 “rolename”이란 이름에 “hero”란 값을 입력하여 DCV를 구분한다.다음으로 User는 Driving module에서 DCV가 자율주행을 하게끔 설정할 수 있고 임의 목적지를 선택하여 주행하도록 설정할 수 있다.주행여부를 선택한 경우 반환된 route-list를 참조하여 DCV는 주행을 시작하고 도착한 경우 이와 같은 현상을 반복하여 주행하게 된다. GUI module은 Carla_GUI.py에서 실행되며 PyQt5 Library를 활용해 GUI를 구성한다. enviroment config remote에서 생성된 주행 차량의 BP(Blueprint)를 검색해 속성(Attribute)이름이 “rolename”인 BP들 중에서 “hero”인 값을 검색한다.대상 차량을 찾았다면 MVC 패턴의 동작구조로 로직이 수행된다.PyQt5로 구현된 GUI는 View 부분으로써 사용자로 부터 각각의 컴포넌트에 입력을 기다린다.사용자는 NPC, Weather, Sensor의 항목을 선택하여 값을 할당한다. NPC의 경우 생성될 보행자와 주행 차량의 대수를 반환하며 Weather의 경우 날씨정보를 반영하기 위한 설정 정보를 입력받는다.Sensor의 경우 앞서 언급한 Camera의 RGB, Depth 와 Lidar를 부착할 수 있다.컴포넌트를 입력한 경우 Controller는 입력된 NPC, Weather, Sensor를 파악하고 이에 따른 기능을 수행하기 위해 Model에 전달하여 컴포넌트에 입력한 값에 해당하는 이벤트 콜백 함수들을 실행하여 시뮬레이션에 반영한다. 1. Driving moduleCARLA package를 이용해 2D 렌더링 환경에서 자율주행 시뮬레이션 시스템의 Data Collection Vehicle(DCV) 제어를 구현함 2D Rendering class HUD_Main : 가상환경내 NPC, DCV같은 오브젝트들의 서페이스정보를 설정하여 화면에 렌더링하며 출력될 텍스트 속성을 설정할 수 있음 (UE4에 생성된 BP 오브젝트를 그려넣음) class InputControl : 클라이언트의 키보드입력으로 목적지를 지정하거나 지도의 포커스를 변경할 수 있음 class World : 도트로 맵을 그려넣어 가상환경을 2D로 표현하였음 (OpenDRIVE의 도로데이터를 참조하여 표현함) Route Plan global_route_planner.py : DCV의 최단경로 데이터 반환 (Python Lib NetworkX) local_planner_behavior.py : DCV의 PID제어기를 설정하여 전후방/좌우 방향을 제어 behavior_agent.py: DCV의 유동적인 주행을 위해 보행자, 차량, 신호등, 표지판 등에 대한 이벤트를 구성하여 주행 시나리오를 작성하고 이를 수행함 DCV의 주행기능 개요 Screenshot Main에서 DCV를 스폰하고 주행속도, 시작과 끝지점, 주행 스타일을 설정함생성된 DCV의 제어를 위해 loop 로직을 수행하며 agent로부터 반환받은 waypoints_queue는 주행차량의 루트플랜을 나타냄 alt1==TRUE인 경우 루트플랜이 num_min_waypoints의 값보다 많은 경우 다음 주행동선의 시나리오를 수행하며 FALSE인 경우 alternative2 로직을 수행함 alt2==TRUE인 경우 루트플랜 정보가 담긴 waypoints_queue의 길이가 1이하인 경우를 뜻하며 사용자가 지정한 목적지의 경로를 반환받거나 임의 목적지 경로를 반환받으며 FALSE인 경우 주행동선의 시나리오를 수행함 alt3==TRUE인 경우 본 연구 목적에 맞게 확장된 reroute_auto() 메서드를 수행함 이는 차량위치를 기준으로 특정 거리만큼의 위치를 임의목적지로 설정하여 루트플랜을 반환받으며 주행동선의 시나리오를 수행함 alt3==FALSE인 경우 본 연구 목적에 맞게 확장된 reroute_self() 메서드를 수행함 이는 2D 렌더링 화면에서 사용자가 선택한 목적지만큼의 루트플랜을 반환받음 이후 주행동선의 시나리오를 수행함 조건 분기로직을 모두 수행한 후 run_step()을 호출하여 다음 경로선상의 waypoint 까지 주행을 하게됨 apply_control은 DCV가 다음 경로선상의 waypoint 까지 주행을 위해 전/후방 방향과 차량의 속도 값이 계산된 값을 Server(Simulation)에 전달하여 원하는 주행을 행동하게끔 요청함 screen_in_no_rendering_mode.py(Main)12345678910111213141516171819202122232425target = world.try_spawn_actor(blueprint, spawnpoint)# modules initinput_control = key_util.InputControl(\"input control title\", world, map)hud = hud_util.HUD_Main(\"hud title\", args.width, args.height)rendering_world = core_util.World(client, target, \"Simulator Info\", args, timeout=2.0)### 경로추적 생성.start_POI = map.get_waypoint(spawnpoint.location)routeManager = VehicleRouteManager(world, map, target, 20, start_POI)# modules startinput_control.start(hud, rendering_world)print(\"system : check input_control\")hud.start()print(\"system : check hud\")rendering_world.start(hud, input_control)print(\"system : check rendering_world\")# Game loopclock = pygame.time.Clock()while True: clock.tick_busy_loop(20) # Tick all modules routeManager.tick(target) VehicleRouteManager.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class VehicleRouteManager(BehaviorAgent): def __init__(self, world, map, target, speed=20.0, start_POI=None, end_POI=None): self.world = world self.map = map self.debug = world.debug self._start_POI = start_POI # 시작지점 self._end_POI = end_POI # 끝지점 # self.waypoints = map.generate_waypoints(5.0) self.spawn_points = self.map.get_spawn_points() self.speed = speed self.destination_loc = None # 타겟의 현재 경유지점 self.log_check = False # 타겟차량의 속도와 이동경로 신호등 self.move_key = None \"\"\" var name 'behavior' cautious : 약한주행운전 normal : 기본 aggressive : 강한주행운전 var name 'ignore_traffic_light' True : 신호무시 False : \"\"\" self.agent = BehaviorAgent(target, ignore_traffic_light=False, behavior='cautious') # agent self.control = None # 차량의 세부 제어. self.routeDestinationList = Stack() # 경유지 목록 self.routePlannerList = [] self.num_min_waypoints = 2 # 다음 경유지 탐색 시작은 루트플래너 큐리스트에 저장된 웨이포인트가 해당 값 미만 인 경우 시작함. self.test_count = 0 def add_route(self, waypoint): # 경유할 목적지 등록. self.routeDestinationList.push(waypoint) def tick(self, target): remaining_count = len(self.agent.get_local_planner().waypoints_queue) # 타겟차량 루트플랜의 웨이포인트 큐 길이 if remaining_count &gt; self.num_min_waypoints: self.agent.update_information() else: if remaining_count &lt;= 1: # 루트플랜의 경로 포인트가 1 이하 일때 if self.routeDestinationList.is_empty(): # 사용자 목적지 선택 지점의 경로 스택이 비어있음. self.test_count += 1 route = self.agent.reroute_auto() self.routePlannerList = route # 시작점과 끝나는 지점의 Waypoint list 를 반환 else: # 사용자가 선택한 임의 목적지로 경로 할당 end = [self.routeDestinationList.pop(0)] route = self.agent.reroute_self(end) self.routePlannerList = route self.agent.update_information() else: self.agent.update_information() control = self.agent.run_step() # 위 로직 설정 적용 및 동작시작. self.agent.vehicle.apply_control(control) # return -&gt; carla.VehicleControl Screenshot - 기능동작 2. GUI module자율주행 시뮬레이션 시스템에 NPC 생성, 시간, 날씨, 차량 등의 속성 파라미터를 변경하거나 센서 데이터 수집과 같은 환경을 구성하기위한 기능은 위에 제시된 “시스템 개발을 위한 시퀀스모델” 에서의 GUI module부분에서 구현됨. GUI에서 NPC 생성을 위한 NPC_Spawn 항목은 버튼 클릭 시 NPC_Manager class에서 수행하며 차량은 ui_world_npc_vehicle 함수, 보행자는 ui_world_npc_walker 함수에서 기존에 생성된 차량과 보행자를 제거하고 생성됨 GUI에서 Time_Control 항목과 Weather_Control 항목은 각각 시간을 제어하고 날씨를 변경함 class Weather_Manager : 가상환경의 환경적요소를 다루며 세부적으로 시간을 제어하기 위한 Sun과 안개, 비, 바람과 같은 자연환경을 제어하기 위한 Storm이 있음 NPC 생성, 시간, 날씨, 차량 등의 파라미터 변경 프로그램 개요 Screenshot PyQt를 사용해 UI를 구성함 Replace 버튼이 눌렸을 때 editbox 숫자로 보행자와 차량을 생성함 시간은 Radio Button으로 설정하며 날씨는 Slider로 설정함, Dynamic을 선택 시 동적으로 설정됨 Carla_GUI.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203def ui_world_npc_walker(self, input_number): # 보행자 생성 함수 SpawnActor = self.carla_package[0] DestroyActor = self.carla_package[4] if len(self.walkers_list) &gt;= 1: # 생성된 워커 제거 self.client.apply_batch([DestroyActor(x) for x in self.all_id]) self.all_id = [] self.walkers_list = [] time.sleep(0.5) if input_number &gt; 0: percentagePedestriansRunning = 0.0 # 달리는 보행자 수 percentagePedestriansCrossing = 0.0 # 걷는 보행자 수 # 1. 생성하기 위한 랜덤 위치를 선택 spawn_points = [] for i in range(input_number): spawn_point = carla.Transform() loc = self.world.get_random_location_from_navigation() if (loc != None): spawn_point.location = loc spawn_points.append(spawn_point) # 2. 보행자 객체를 생성한다. batch = [] walker_speed = [] for spawn_point in spawn_points: walker_bp = random.choice(self.blueprintsWalkers) # 무적이 아니도록 설정 if walker_bp.has_attribute('is_invincible'): walker_bp.set_attribute('is_invincible', 'false') # 최고 속도로 설정 if walker_bp.has_attribute('speed'): if (random.random() &gt; percentagePedestriansRunning): # 걷는 보행자 walker_speed.append(walker_bp.get_attribute('speed').recommended_values[1]) else: # 달리는 보행자 walker_speed.append(walker_bp.get_attribute('speed').recommended_values[2]) else: logging.warning(\"Walker has no speed\") walker_speed.append(0.0) batch.append(SpawnActor(walker_bp, spawn_point)) results = self.client.apply_batch_sync(batch, True) walker_speed2 = [] for i in range(len(results)): if results[i].error: pass else: self.walkers_list.append({\"id\": results[i].actor_id}) walker_speed2.append(walker_speed[i]) walker_speed = walker_speed2 # 3. 보행자 controller를 설정 batch = [] walker_controller_bp = self.world.get_blueprint_library().find('controller.ai.walker') for i in range(len(self.walkers_list)): batch.append(SpawnActor(walker_controller_bp, carla.Transform(), self.walkers_list[i][\"id\"])) results = self.client.apply_batch_sync(batch, True) for i in range(len(results)): if results[i].error: pass else: self.walkers_list[i][\"con\"] = results[i].actor_id # 4. 모든 보행자와 보행자 controller의 id를 각각을 설정 for i in range(len(self.walkers_list)): self.all_id.append(self.walkers_list[i][\"con\"]) self.all_id.append(self.walkers_list[i][\"id\"]) all_actors = self.world.get_actors(self.all_id) # 5. 각 controller를 초기화하고 대상을 걸어갈 타켓 설정 # 길을 건널 수 있는 보행자수 설정 self.world.set_pedestrians_cross_factor(percentagePedestriansCrossing) for i in range(0, len(self.all_id), 2): # 보행자 설정 시작 all_actors[i].start() # 보행자에게 랜덤 생성 위치 설정 all_actors[i].go_to_location(self.world.get_random_location_from_navigation()) # 속도는 최대로 설정 all_actors[i].set_max_speed(float(walker_speed[int(i / 2)])) if not self.args.sync or not synchronous_master: self.world.wait_for_tick() else: self.world.tick() count = len(self.walkers_list) count_fail = input_number - count print('보행자 %d 오브젝트 충돌, 보행자 %d 스폰' % (count_fail, count))def ui_world_npc_vehicle(self, input_number): # 차량 생성 함수 SpawnActor = self.carla_package[0] SetAutopilot = self.carla_package[1] SetVehicleLightState = self.carla_package[2] FutureActor = self.carla_package[3] DestroyActor = self.carla_package[4] # test var target_actor_attr = TargetActorAttr(self.world) if len(self.vehicles_list) &gt;= 1: # 생성된 차량 제거 self.client.apply_batch([DestroyActor(x) for x in self.vehicles_list]) self.vehicles_list = [] time.sleep(0.5) if input_number &gt; 0: # 차량 생성 batch = [] for n, transform in enumerate(self.spawn_points): if n &gt;= input_number: break blueprint = random.choice(self.blueprints) if blueprint.has_attribute('color'): color = random.choice(blueprint.get_attribute('color').recommended_values) blueprint.set_attribute('color', color) if blueprint.has_attribute('driver_id'): driver_id = random.choice(blueprint.get_attribute('driver_id').recommended_values) blueprint.set_attribute('driver_id', driver_id) # light state 생성 light_state = vls.NONE # 자동차 자동주행 설정 light_state = vls.Position | vls.LowBeam | vls.LowBeam # 차량을 생성하고 자동주행과 light state을 동시에 설정 batch.append(SpawnActor(blueprint, transform) .then(SetAutopilot(FutureActor, True, self.traffic_manager.get_port())) .then(SetVehicleLightState(FutureActor, light_state))) for response in self.client.apply_batch_sync(batch, self.synchronous_master): if response.error: pass else: self.traffic_manager.global_percentage_speed_difference(10.0) # 제한 속도의 10% 속도로 주행 self.vehicles_list.append(response.actor_id) time.sleep(0.5) count = len(self.vehicles_list) count_fail = input_number - count print('차량 %d 오브젝트 충돌, 차량 %d 스폰' % (count_fail, count))def NPC_Spawn(self): # NPC 버튼 클릭 후 값 가져오기 people = int(self.Edit_People.text()) vehicle = int(self.Edit_Vehicle.text()) self.ui_data.set_NPC_Spawn(people, vehicle) self._npc.ui_world_npc_vehicle(self.ui_data.A_vehicle) self._npc.ui_world_npc_walker(self.ui_data.A_people) print(\"Spawn Complete\")def groupbox_Time_Function(self): # 시간 변경 radio 버튼 함수 elapsed_time = 0 if self.radioButton_1.isChecked(): self.ui_data.B_sun_type = \"midday\" elif self.radioButton_2.isChecked(): self.ui_data.B_sun_type = \"sunset\" elif self.radioButton_3.isChecked(): self.ui_data.B_sun_type = \"midnight\" elif self.radioButton_auto.isChecked(): if self.ui_data.B_remote is True: self.ui_data.B_remote = False else: self.ui_data.B_remote = True self._weather_set = ui.UI_INPUT_CONTROL().return_weather(clouds=self.ui_data.C_cloud, rain=self.ui_data.C_rain, wetness=self.ui_data.C_rain * 5, puddles=self.ui_data.C_rain, wind=self.ui_data.C_wind,fog=self.ui_data.C_fog, remote=self.ui_data.C_remote) self._sun_set = ui.UI_INPUT_CONTROL().return_sun_type(sun_type=self.ui_data.B_sun_type, remote=self.ui_data.B_remote) timestamp = self.world.wait_for_tick().timestamp elapsed_time += timestamp.delta_seconds self._weather.tick(elapsed_time, self._weather_set, self._sun_set)def show_Slider_weather(self): # 날씨 번경 Slider elapsed_time = 0 self.ui_data.C_fog = self.horizontalSlider_fog.value() self.ui_data.C_rain = self.horizontalSlider_rain.value() self.ui_data.C_wind = self.horizontalSlider_wind.value() self.ui_data.C_cloud = self.horizontalSlider_clouds.value() self._weather_set = ui.UI_INPUT_CONTROL().return_weather(clouds=self.ui_data.C_cloud, rain=self.ui_data.C_rain, wetness=self.ui_data.C_rain * 5, puddles=self.ui_data.C_rain, wind=self.ui_data.C_wind,fog=self.ui_data.C_fog, remote=self.ui_data.C_remote) self._sun_set = ui.UI_INPUT_CONTROL().return_sun_type(sun_type=self.ui_data.B_sun_type, remote=self.ui_data.B_remote) timestamp = self.world.wait_for_tick().timestamp elapsed_time += timestamp.delta_seconds self._weather.tick(elapsed_time, self._weather_set, self._sun_set)def show_checkBox_weather(self): # 날씨 번경 checkBox if self.checkBox_weather_auto.isChecked(): if self.ui_data.C_remote is True: self.ui_data.C_remote = False else: self.ui_data.C_remote = Truedef speed_control(self): # 속도 제어 speed = int(self.lineEdit_speed.text()) self.ui_data.D_speed = speeddef auto_control(self): # Auto if self.checkBox_etc_auto.isChecked(): if self.ui_data.D_remote is True: self.ui_data.D_remote = False else: self.ui_data.D_remote = True Screenshot - 기능동작 센서를 통한 데이터 수집 프로그램 개요 센서를 통한 데이터 수집은 Seneor_Manager class를 호출하여 센서를 생성하고 센서가 부착될 위치와 세부 옵션을 설정할 수 있음 Camera_Rgb : 카메라 위치(x, y, z, roll, pitch, yaw)와 이미지의 크기, fov(카메라의 수평시야), Shutter 속도, 감도 등의 촬영 옵션을 설정해 촬영 Camera_Depth : RGB 카메라처럼 이미지를 저장하고 carla.ColorConverter.Depth을 적용해 깊이를 이미지에 적용 Sensor_Lidar : 레이저의 수, 각도, 측정거리, 포인트 수 등을 설정해 촬영 Screenshot Setting 버튼은 사용자가 선택한 센서를 데이터 수집 차량의 부착함 센서의 속성과 차량의 부착위치는 각각의 editbox에 값으로 설정됨 Play 버튼을 통해 센서의 데이터 수집을 시작함 Stop 버튼을 통해 센서의 데이터 수집을 멈출 수 있음 Carla_GUI.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214class Sensor_Manager(object): def __init__(self, world, target, config): self.check = False self.index = -1 self.world = world self.target = target self.args = config self.sensor = None self.recoding_check = False self.radar_sensor = None self.sensor_imu = None self.sensor_gnss = None def set_recording(self, check=False): self.sensor.set_recording(self.recoding_check) def recording(self): # 녹화 시작과 녹화 종료 설정 if self.recoding_check is False: self.recoding_check = True print(\"녹화시작\") elif self.recoding_check is True: self.recoding_check = False print(\"녹화종료\") self.sensor.set_recording(self.recoding_check) def select_sensor(self, index=-1, sensor_option=None, sensor_position=None): self.args.sensor_option = sensor_option self.args.sensor_position = sensor_position if self.sensor is None: if index == -1: print(\"sensor Camera_Rgb\") self.sensor = Camera_Rgb(self.world, self.target, self.args) elif index == 0: print(\"sensor Camera_Rgb\") self.sensor = Camera_Rgb(self.world, self.target, self.args) elif index == 1: print(\"sensor Camera_Depth\") self.sensor = Camera_Depth(self.world, self.target, self.args) elif index == 2: print(\"sensor Lidar\") self.sensor = Sensor_Lidar(self.world, self.target, self.args) return self.sensor else: return self.sensor def destroy(self): self.sensor.destroy() if self.radar_sensor is not None: self.radar_sensor.destroy() if self.sensor_imu is not None: self.sensor_imu.destroy() if self.sensor_gnss is not None: self.sensor_gnss.destroy() self.radar_sensor = None self.sensor = Noneclass Sensor_Lidar: def __init__(self, world, target, config): self.world = world self.bp_library = world.get_blueprint_library() self.target = target self.sensorActor = None self.recording = False self.surface = None # &lt;- 2020-08-07추가 self.dim = (config.width, config.height) self.sensor_option = config.sensor_option self.sensor_position = config.sensor_position item = self.sensor_option bp_library = world.get_blueprint_library() bp = bp_library.find(item[0]) for attr_name, attr_value in item[2].items(): bp.set_attribute(attr_name, attr_value) if attr_name == str('range'): print(\"check=====\") self.lidar_range = float(attr_value) sensor = self.world.spawn_actor(bp, self.sensor_position, attach_to=self.target) weak_self = weakref.ref(self) sensor.listen(lambda point_cloud: Sensor_Lidar._parse_image(weak_self, point_cloud, item[1])) self.sensorActor = sensor # 설정된 센서 저장. def set_recording(self, check=False): self.recording = check def destroy(self): # target 센서 제거. self.sensorActor.destroy() @staticmethod def _parse_image(weak_self, image, id): # 센서 수집 이미지 저장 self = weak_self() if self.recording: simulation_time = image.timestamp time = datetime.timedelta(seconds=int(simulation_time)) time = str(time).replace(':', '-') image.save_to_disk('sensor/' + str(id) + '/%s' % time + '/%08d' % image.frame) def render(self, display): if self.surface is not None: display.blit(self.surface, (0, 0))class Camera_Depth: def __init__(self, world, target, config): self.world = world self.bp_library = world.get_blueprint_library() self.target = target self.sensorActor = None self.recording = False self.surface = None self.sensor_option = config.sensor_option self.sensor_position = config.sensor_position item = self.sensor_option bp_library = world.get_blueprint_library() bp = bp_library.find(item[0]) for attr_name, attr_value in item[4].items(): bp.set_attribute(attr_name, attr_value) sensor = self.world.spawn_actor(bp, self.sensor_position, attach_to=self.target) weak_self = weakref.ref(self) sensor.listen(lambda image: Camera_Depth._parse_image(weak_self, image, item[1], item[3])) self.sensorActor = sensor # 설정된 센서 저장. def set_recording(self, check=False): self.recording = check def destroy(self): # target 센서 제거. self.sensorActor.destroy() @staticmethod def _parse_image(weak_self, image, cc, id): self = weak_self() image.convert(cc) array = np.frombuffer(image.raw_data, dtype=np.dtype(\"uint8\")) array = np.reshape(array, (image.height, image.width, 4)) array = array[:, :, :3] array = array[:, :, ::-1] if self.recording: simulation_time = image.timestamp time = datetime.timedelta(seconds=int(simulation_time)) time = str(time).replace(':', '-') image.save_to_disk('sensor/' + str(id) + '/%s' % time + '/%08d' % image.frame) def render(self, display): if self.surface is not None: display.blit(self.surface, (0, 0))class Camera_Rgb: def __init__(self, world, target, config): self.world = world self.bp_library = world.get_blueprint_library() self.target = target self.sensorActor = None self.recording = False self.surface = None self.sensor_option = config.sensor_option self.sensor_position = config.sensor_position item = self.sensor_option bp_library = world.get_blueprint_library() bp = bp_library.find(item[0]) for attr_name, attr_value in item[4].items(): bp.set_attribute(attr_name, attr_value) sensor = self.world.spawn_actor(bp, self.sensor_position, attach_to=self.target) weak_self = weakref.ref(self) sensor.listen(lambda image: Camera_Rgb._parse_image(weak_self, image, item[1], item[3])) self.sensorActor = sensor # 설정된 센서 저장. def set_recording(self, check=False): self.recording = check def destroy(self): # target 센서 제거. self.sensorActor.destroy() @staticmethod def _parse_image(weak_self, image, cc, id): self = weak_self() image.convert(cc) array = np.frombuffer(image.raw_data, dtype=np.dtype(\"uint8\")) array = np.reshape(array, (image.height, image.width, 4)) array = array[:, :, :3] array = array[:, :, ::-1] if self.recording: simulation_time = image.timestamp time = datetime.timedelta(seconds=int(simulation_time)) time = str(time).replace(':', '-') image.save_to_disk('sensor/' + str(id) + '/%s' % time + '/%08d' % image.frame)def Sensor_Play(self): # QyPt 구현 부분 print(\"센서 데이터 수집\") for n, _sensor in enumerate(self._sensor_list): _sensor.recording()def Sensor_Stop(self): print(\"센서 종료\") for n, _sensor in enumerate(self._sensor_list): _sensor.recording()def closeEvent(self, event): # 창 종료시 이벤트 발생 for n, _sensor in enumerate(self._sensor_list): _sensor.destroy() Screenshot - 기능동작 잡담개발팀 spaceTime Lab은 공간정보에 관련된 여러 R&amp;D과제를 지도교수님 주도로 수행해왔다. 이번에 자율주행에 관한 흥미로운 주제를 가져오셔서 해당 연구과제를 수주하고 진행하게 되었다.주력언어가 java였던 나는 Python을 다뤄보지않아 문법 자체를 몰랐다.지도교수님이 진행하려던 과제는 실세계 정보를 반영한 오픈소스 기반의 자율주행 시뮬레이션 시스템 설계 및 구현 이 목표였다.과제주제가 보기만 해도 사람 쫄리게 만드는 주제다.. 중요한건 자율주행에 관한 대부분의 플랫폼들은 실행언어로 대부분 C++이나 Python이 주력을 이루고 있었다.(한번도 써보지 않은 언어..)본 연구에서 기반을 두었던 플랫폼은 Carla-Simulator였고 오픈소스 플랫폼이다. 그래서 모든것이 공개되어 있다.그중 CarlaAPI는 C++로 자율주행 기능의 코어가 구현되어 변형하여 사용하거나 C++을 Python의 확장모듈로 변환하여 활용하는 방법이 있었다.개발에 있어서 핵심 모듈을 수정하기보단 확장모듈로 API를 활용해 개발하는 것이 프로젝트 기간상 제한적인 시간동안 개발하기 수월하다고 생각하여 팀원들과 협의하에 Python으로 진행하게 되었다. Python을 처음으로 써보는데도 문법이 단순하여 쉽게 받아드릴 수 있었다.(들여쓰기가 불편했다.)java와는 다른 선언방법이 초기에만 불편함을 주었을 뿐이였고.. 코드 자체가 복잡하지 않았다. 기존의 Python으로 개발된 CarlaAPI의 오픈소스를 참고하여 선언방식이나 프로젝트의 구조 등 알아갔고구글링이나 Python기초책을 봐가며 Java와는 다른 버퍼데이터를 처리하는 방법을 배워갔다. Carla-Simulator의 오픈소스의 이점으로 누구나 비용적인 부분을 걱정없이 사용할 수 있다.그덕인지 시뮬레이터의 빌드부터.. 시스템에러 등 엄청나게 다양한 이슈들이 Discord, Reddit, Github등 커뮤니티에 활발하게 공유되고 해결되고 있다.덕분에 프로젝트 기간동안 벽에 부딪히는 대부분을 커뮤니티에서 이슈를 찾아 해결할수 있었다. ^_^ (삽질이 많았다는 뜻.) 변환하기 위한 정밀도로지도는 국토지리정보원에서 배포중인 데이터를 사용했다.ShapeFile로 제공된 해당 데이터는 데이터 모델이 Node-Link 체계로 구성된다. 산업계표준모델인 OpenDRIVE로 변환해야 하는 과정이 별도로 필요한데국토지리정보원에서 제공중인 정밀도로지도데이터의 내부는 도로의 레이어마다 ID형태로 이어져 있고 모든 교차로와 일반 주행도로의 Node간 연결이 안되어있다.이를 연결해야하는데 정밀도로지도를 제작한 업체가 한곳이 아닌 여러곳이다. 업체마다 협의가 제대로 안된건지 제작업체마다 Node-Link ID가 다르다.OpenDRIVE 변환을 위해서 Node-Link가 전부 연결된 상태로 중앙선을 임의로 만들어 변환해야 한다. 또한 포켓차로와 같이 추가차선들이 직선도로와 연결이 안된부분이 상당 수다.지하차도의 구분이 안되어 있어 이또한 문제다.. 우리나라에서 제공한 정밀도로지도를 자율주행 시뮬레이터에 적용해 쓰기에는 현실적으로 많은 시간과 인력이 필요해보인다..자율주행 수행을 위한 정밀도로지도의 세부적인 옵션이 부실하기 때문에 이게 개선되기까지 얼마나 기다려야할까 기대되는 부분이다..","link":"/2021/01/18/Carla-simulator/"},{"title":"Lambda Expression 기초","text":"목차 기존 메서드와의 문법 비교 @Functional Interface java.util.function 패키지 JDK1.8 이 추가되면서 자바의 문법구조가 크게 변화하였다.기존 JAVA의 문법에 너무 익숙해져 있는 바람에 람다식을 구지 사용해야하나 라는 의문을 가지고 있었으나 익명함수 선언 과정에서 람다식은 코드의 구조를 매우 간결하게 만들어준다.JDK1.5에 추가된 Generics을 함께 사용하여 RxJava와 Spring5.0 이후 추가된 WebFlux를 이루는 ReactiveStream은 람다와 제네릭이 매우 중요하게 다뤄지는데 조비동기 논블럭킹 방식의 앱을 구성하는데 있어 꼭 알아야할 문법 구조이다. 기존 메서드와의 문법 비교+Lambda Expression에서 Lambda는 익명함수를, Expression은 식 이다. 이는 선언하고자하는 메서드의 선언을 익명으로 객체에 주입한다. 기존의 메서드 정의1234public int compare(int num1, int num2) { return num1 &gt; num2 ? num1 : num2; } 람다식 메서드 정의1(num1, num2) -&gt; num1 &gt; num2 ? num1 : num2; 람다식은 앞서 말한 듯 익명함수를 뜻한다 메서드 선언을 비교하니 기존의 ‘반환타입’ 과 ‘메서드명’ 이 제거되고매개변수의 타입 대신에 추론 가능한 변수명을 대입한다. 아래의 경우는 자바에서 선언한 메서드를 람다식으로 표현 한 경우의 ‘예’ 이다.람다식은 Functional Interface 항목에서 구현해본다. 기존 메서드 선언과 어떻게 다른지 비교만 해보자. 1234567public void printVar(String name, int age) { System.out.println(name + \"=\" + age); } ↓↓↓↓ (name, age) -&gt; System.out.println(name + \"|\" + age); 매개변수가 하나인 경우 ‘()괄호’ 생략 가능. 1234567891011121314151617 public int sumArr(int[] arr) { int sum = 0; for (int i : arr) { sum += i; } return sum; } ↓↓↓↓ arr -&gt; { int sum = 0; for (int i : arr) { sum += i; } return sum; }; 1234567public int roll() { return (int) (Math.random() * 6); } ↓↓↓↓ () -&gt; (int) (Math.random() * 6); 기존의 메서드 구성방식과 람다식의 방식을 비교해봤다. 람다의 익명함수는 지금껏 사용해온 익명객체선언과 동일하다. 익명객체선언123456new LambdaTest() { @Override public int roll() { return (int) (Math.random() * 6); } }; 익명함수선언1() -&gt; (int) (Math.random() * 6); @Functional Interface+Functional Interface는 람다식 호출을 위해 필요하며 interface에서 구현할 람다식의 추상메서드를 선언하고 해당 interface를 구현 할 객체에 선언해주면 된다.단, 익명객체를 익명함수인 람다로 대체하기 위해선 해당 메서드의 타입과 매개변수의 개수를동일하게 선언해야만 한다.아래의 예는 함수형 interface, LambdaTest를 정의한 것이다. 1234@FunctionalInterfaceinterface LambdaTest { public abstract String test(String data,int id);} 여기서 눈에 띄는 것은 @FunctionalInterface 애노테이션인데 이는 컴파일 과정에서 LambdaTest를 올바르게 구현했는지 여부를 확인해 준다. 해당 구현체를 선언한다면 다음과 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test { public Test() { } public Test(LambdaTest lambdaTest) { } public void testMethod(LambdaTest lambdaTest) { } public static void main(String[] args) { //익명함수객체주입 LambdaTest lambdaTest = (data, id) -&gt; { String str = data; int i = id; ... }; //익명함수생성자주입 Test test = new Test((data, id) -&gt; { String str = data; int i = id; ... }); //익명함수메서드주입 Test test = new Test(); test.testMethod((data, id) -&gt; { String str = data; int i = id; ... }); //기존의익명클래스객체주입 LambdaTest lambdaTest = new LambdaTest() { public String test(String data, int id) { ... return \"\"; } }; } } 람다식을 통한 선언방식은 위와같이 익명함수를 통한 방법, 생성자 매개변수 선언을 통한 방법, 메서드의 매개변수 선언을 통한 방법다음의 3가지 방법이 있다. 이 방식은 기존의 익명클래스 선언과 다르지 않고 동일하나 람다식을 통해 코드의 구성이 좀더 직관성을 이루며 간결해진다. List객체에 Lambda를 적용한 예토비스프링 강의참고 java.util.function 패키지+","link":"/2019/05/01/Lambda-Expression%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9/"},{"title":"java.NIO 패키지를 활용한 Reactor-Pattern 채팅","text":"Intro Old I/O의 문제점 과 이를 개선한 New I/O프로젝트파일 : https://github.com/Kimbaro/SocketChatApp.git Environment IntelliJ IDEA IntelliJ Plugin, UI Designer(Java Swing GUI) Java (openjdk 1.8.0_232) Apache Commons Codec 1.14 Main Function Old I/O pattern의 ServerSocket을 New I/O Reactor Pattern의 ServerSocketChannel로 변경 적용하여 기존 동기화 방식의 소켓채팅을 비동기 방식의 소켓 채팅으로 변경. 하나의 채팅프로그램에서 동적으로 변경 가능한 BroadCast통신과 UniCast통신 적용. 클라이언트 임의의 비밀키를 생성하고 데이터 암호화를 적용하고 해당 데이터를 클라이언트와 서버와의 공개키를 활용한 이중암호화를 적용한 대칭키암호 AES256 알고리즘 적용한 암호화 통신 적용. 네트워크 프로그래밍의 기존 소켓 통신은 아래와 같은 패턴을 따른다. 클라이언트가 Connect()를 수립한 경우 서버의 accept()에 의해 Client Socket이 반환된다 이를 동기중인 클라이언트소켓이라 생각해도 무방하다. 해당 소켓을 활용해 I/O를 로직의 반복루프를 통해 새로 들어온 데이터가 있는지 체크 한다.이 경우 데이터를 체크하고 보내고 받기 위한 작업은 SubThread에서 처리한다. 위 그림과 같이 기존의 과정의 경우 문제가 발생할 수 있다.클라이언트(접속자)가 많아 질수록 그만큼 스레드는 클라이언트 접속자에 맞춰 계속해서 늘려가야 한다.이 경우 메모리 구조상 Stack영역과 Heap영역의 무분별한 할당이 진행될 것이다. 아래 그림 처럼, 새로운 클라이언트의 접속(붉은색)이 발생(Accept)할 때 MainThread는 SubThread(주황색)를 생성한다. N명의 접속이 발생할 경우접속한 N명의 수에따라 SubThread를 계속해서 생성하며 과도한 접속이 발생할 경우 그에 따른 부담이 발생할 수 있다. 이런 무분별한 메모리 영역 낭비를 보완하여 NIO란 방식이 고안되었다.NIO를 Non-blocking Input/Output 또는 New Input/Output이라 부르고 있다.Java에선 JDK1.4부터 이를 지원하기 시작하였으며, Client가 연결을 시도할 경우 해당 클라이언트를 구분하기 위한 채널(SocketChannel) 객체를 생성한다. 이후 Selector객체는 각 채널(SocketChannel)의 소켓 연결 이벤트(Connect, Accept, Read, Write)에 반응하여 이벤트가 발생한 채널의 키를 반환한다. 상황에 반응(Reactor)하여 작업을 시도하는데 여기서 키는 서버와 연결된 Client의 대상을 구분하기 위한 식별자이며네트워크정보를 포함하고 있다. 아래의 이미지와 같다. 이러한 과정을 Reactor-Pattern이라 하며 우리말로 반응형 패턴이라 볼 수 있다.이제 해당 패턴을 적용한 채팅프로그램을 리뷰한다.java.nio 패키지에서 활용되는 주요 클래스의 역할을 알아본다. SocketChannels : 소켓을 통해 non-blocking read를 할 수 있도록 지원하는 connection. Selector : Selector는 어느 channel set 이 IO event 를 가지고 있는지를 알려준다. Selector.select() 는 I/O 이벤트가 발생한 채널 키를 return한다.return channel이 없다면 계속 기다리게(block) 된다. 2번의 과정에 의해 block된 Selector를 강제로 동작 시켜주는 것이 Selector.wakeup()이다. Selector.selectedKeys()는 이벤트가 발생한 키, 즉 SelectionKey 를 return 해 준다. Reactor는 이 SelectionKey를 보고 어떤 handler로 넘겨줄 지를 결정한다. SelectionKey : Selector와 Channel간의 관계를 표현해주는 객체이다. Selector가 제공한 SelectionKey를 이용해 Reactor는 채널에서 발생하는 I/O 이벤트로 수행할 작업을 선택할 수 있다. ServerSocketChannel에 selector를 등록하면 key를 준다. 이 key가 SelectionKey 이다. 리뷰Part 1. NIO를 위한 객체 생성 (NiochatServer.class) 13 : Runnable을 implements하고 있음을 유의한다.17 : Server의 SocketChannel을 생성한다. 클라이언트의 accept를 수립하는 역할을 한다.18 : 생성된 모든 채널 정보와 각 채널의 이벤트 정보를 담고 있는 역할을 한다.28 - 29 : Selector와 SecverSocketChannel 객체는 open() 메서드로 초기화 한다.31 - 33 : ServerSocketChannel의 메서드는 다음과 같다. socket() : ServerSocket을 반환한다. 이후 네트워크에 IP,PORT를 바인딩한다. configureBlocking() : true인 경우 Blocking, false인 경우 Non-Blocking register() : Selector(선택자)에 서버의 채널정보(Key)를 등록하고 OP_ACCEPT 이벤트를 발생한다. Part 2. 이벤트 반응(Reactor) (NiochatServer.class) 45 : 저장된 Keys 중 이벤트(Connect, Accept, Read, Write)가 감지될 때 까지 Block상태로 대기한다. 이벤트가 발생할 경우 이에 반응해 해당하는 클라이언트(Key)를 SelectionKey객체로 반환한다.51 : Selector와 SelectionKey를 인자로 받아 이벤트를 처리 작업을 진행한다. (EventManager내부로직은 아래서 다시 설명.)53 : 인자로 받은 SelectionKey중 OP_ACCEPT와 같은 이벤트인 경우 해당 클라이언트(Key)를 accept 하기 위한 메서드 이다.55 : 인자로 받은 SelectionKey중 OP_ACCEPT를 제외한 다른 이벤트인 경우 subThread를 생성해 read/write 또는 disConnect여부를 처리 후 종료한다. 참고 - SelectionKey에서 제공 중인 이벤트 상수는 다음과 같다. Part 3. 이벤트 처리 (EventManager.class Thread) 19 : EventManager객체는 Runnable을 implement 하고 있음을 유의한다.24 - 26 : Selector.select()에 의해 반응한 이벤트정보가 담긴 SelectionKey를 인자로 받는다.33 - 50 : 인자로 받은 SelectionKey에 담긴 이벤트가 무엇인지 key.interestOps() 함수로 반환 받으며, switch-case를 통해 어떤 이벤트인지 판단한다. 본 채팅 프로그램에서 구현한 이벤트는 송/수신 부분이다. 서버는 해당하는 키채널에게 수신받을 준비가 되었음. READ =&gt; SelectionKey.OP_READ서버는 해당하는 키채널에게 송신할 준비가 되었음. WRITE =&gt; SelectionKey.OP_WRITESelector가 처리할 수 있는 이벤트 요소가 무엇이 있는지는 이미지(SelectionKey에서 제공 중인 이벤트 상수)를 참고. Part 4. (Function 1) OP_ACCEPT 이벤트 기능 구현, EventManager.handleAccept(Selection key) 54 : (그림6 52번 라인 참고) Selector가 OP_ACCEPT이벤트를 감지할 경우 대상 키를 반환받아 SelectionKey.accept()로 서버에 접속을 수용한다. 이 경우 Selector내부에 해당 클라이언트의 네트워크 정보가 담긴 Key 채널을 저장한다.58 : 해당 클라이언트의 이벤트처리 동작을 non-blocking으로 수행한다. true인 경우 blocking으로 수행한다.59 : Selector에 최종적으로 클라이언트 채널을 등록하며 해당 채널의 이벤트 상태를 OP_READ로 대기한다. =&gt; OP_READ로 지정하여 클라이언트가 connect하면서 보낸 메시지를 읽는다. Part 5. (Function 2) OP_READ 이벤트 기능 구현, EventManager.handleRead(Selection key) 70 : 이벤트 변경감지된 클라이언트키(Selection key)를 인자로 key.channel() 메서드를 통해 해당 키의 네트워크정보가 담긴 채널 객체 SocketChannel을 생성한다.74 : 클라이언트가 보낸 데이터는 바이트버퍼로 이뤄져 있으며, SocketChannel.read(ByteBuffer dst)에서 매개변수로 지정된 ByteBuffer 값 만큼 단위로 끊어 읽는다. 읽어낸 값은 StringBuilder에 의해 대용량문자데이터를 입력받아 초기화한다.84 : 클라이언트가 종료하여 클라이언트의 Write Thread가 0byte를 보낸다면 서버는 데이터를 “exit:”로 초기화하여 EventManager.strAPI() 함수에서 처리한다. Part 6. (Function 3) OP_WRITE 이벤트 기능 구현, EventManager.handleWrite(Selection key) 97 : 해당 클라이언트 Key에 부착된 ClientOption을 반환받는다. 클라이언트의 전반적인 기능과 정보가 담겨있고 이벤트 진행여부를 스위치 하기위한 정보가 담겨있다.99 : ClientOption에 1:1 대화를 위한 상대방 클라이언트 Key가 저장되어 있는지 파악한다. 해당 if구문으로 해당 클라이언트가 브로드캐스트상태인지 유니캐스트상태인지 구분하고 있다.100 : 신규로 채팅방에 접속한 클라이언트인지 여부를 구분한다. 신규 유저인 경우 서버에서 채팅방 참여중인 클라이언트 모두에게 join: 기능의 메시지를 뿌려 소개한다.105 - 116 : 현재 채팅방에 접속중인 클라이언트 닉네임을 ‘,’콤마 단위로 구분해 문자열로 저장한다.118 - 119 : 서버가 클라이언트에게 보내는 내용은 다음과 같다.join:{클라이언트닉네임}:{ClientNickname1,ClientNickname2,ClientNickname3, . . .}이후 해당 내용을 브로드캐스팅한다.121 : 만일 신규접속자가 아닌 경우 클라이언트 메시지를 read하여 브로드캐스팅한다.125 : 99번 라인에서 1:1대화를 위한 상대방 클라이언트 Key가 Null이 아니라면 클라이언트와 1:1 대화를 요구하는 파트너의 키를 인자로 유니캐스트를 진행한다.134 : Selector의 이벤트 상태를 OP_READ로 변경하여 클라이언트로부터 데이터를 받을 준비를 한다.135 : Selector.select()에서 블로킹 상태를 깨워 로직을 진행한다. Part 7. (Function 4) 브로드캐스팅 동작 구현, EventManager.broadcast(String msg) 138 : Selector.keys()를 통해 등록된 채널(Key)를 반환한다.139 : 해당 채널이 유효한지 판단 하는 key.isValid()와 네트워크 정보가 담긴 channel()를 반환해 유효하며 네트워크 정보가 담겨 있는지 여부를 파악 후 SocketChannel의 인스턴스를 반환한다.142 : SocketChannel.write()는 서버가 해당 소켓 채널에 메시지를 보낸다. Part 8. (Function 5) 유니캐스팅 동작 구현, EventManager.unicast(String msg, SelectionKey partnerKey) 155 : unicast()의 두 번째 매개변수인 partnerKey는 클라이언트간 1:1 대화를 위한 상대방 키 정보이다.158 - 163 : 두 채널 정보가 담긴 whisperUsers 배열을 for-each 루틴으로 두 채널에 메시지를 보내는 과정이다. Part 9. (Function 6) 서버와 클라이언트간 약속된 명령어 EventManager.strAPI(String data, clientKey) 모든 String data값은 split‘:’ 을 통해 분류된다. APIs 형식 기능 join: join:{user nickname value} 신규 참여자 임을 서버에 알리며 닉네임을 포함한다. message: message:{message} 채팅메시지를 포함한다. exit: exit: 클라이언트 채팅 종료 whisper: whisper:{partner nickname value}:{message} 1:1 채팅을 위해 파트너 닉네임과 메시지를 포함한다. envelope: envelope:{private key@data} AES256 대칭키 암호화 데이터를 전송한다. unknown Type - 아무런 타입도 없다면 message: 로 처리한다. Part 9.1 (API type = join) join: 의 이벤트 처리 클라이언트는 connect 요청 시 join: 메시지를 함께 전송한다.해당 클라이언트의 채널은 SelectionKey.attach()에 독점자원인 ClientOption을 초기화하여 해당 클라이언트의 다양한 상황에 따른 스위치 역할을 한다. Part 9.2 (API type = message) message: 의 이벤트 처리 메시지를 split하여 해당 클라이언트의 attacment객체의 ClientOption에 문자열을 할당한다.이후 SelectionKey.interestOps()로 현재 SelectionKey의 이벤트처리 유형을 OP_WRITE로 변경하고 Selector.wakeup()로 block 상태인 Selector.select() 스레드를 동작 시킨다. Part 9.3 (API type = exit) exit: 의 이벤트 처리 exit인 경우 해당 채널을 닫고 =&gt; SelectionKey.channel().close()해당 내용을 각 클라이언트에게 브로드캐스팅한다. Part 9.4 (API type = envelope) envelope: 의 이벤트 처리 본 어플리케이션에서 암호화는 두단계로 이뤄진다.공유키(Public Key)는 클라이언트와 서버만 알고 있는 암호키 이다.클라이언트는 비밀키(Private Key)를 공유키로 자신을 암호화한다.비밀키는 클라이언트가 작성한 평문(Plain Message)를 암호화한다. 이후 문자를 조합해 서버로 보낸다. 형식은 다음과 같이.envelope:{공유키로 암호화된 비밀키}@{비밀키로 암호화된 암호문} 의 형식으로 이뤄져 있다.위 이미지는 클라이언트에서 처리하는 암호화 과정이다. 동작1. 메시지 암호화 및 송/수신 팝업에서 확인 클릭 시 암호화된 메시지로 변환 채팅 내용을 보면 ‘@’가 확인됨. 해당 문자 기준 좌측은 암호화된 키, 우측은 암호화된 문자로 구분함. 클라이언트에서의 암호화 전송 시 로그 서버에서의 암호화 수신 시 로그. 복호화 정상 확인. 2. 귓속말(1:1) 채팅 테스트 test123이 test3과 test2각각의 사용자에게 메시지를 보냈다.결과, 보낸 대상 외 다른 사용자는 해당 메시지를 확인하지 못하게 된다. Report비동기 방식의 시스템 전망간단히 java를 활용해 비동기적인 채팅앱을 만들어 보았다. 느낀점은 다음과 같다.기존 NIO방식은 java의 내부 패키지인 java.NIO에서 제공하고 있었으나, 이러한 비동기적 패턴을 SpringBoot Framwork의 MSA기반이 되는 Project Reactor 에서 채택하여 개별적으로 reactor.netty.tcp ,udp, http와 같은 패키지를 제공함에 따라 비동기방식의 Reactor-Pattern의 채팅을 구현할 수 있게 되었다.중요한 포인트는 Project-Reactor는 SpringBoot MSA환경 최적화된 프레임워크이다. 이에 단순히 java project를 통한 채팅앱이 아닌 reactor.netty 패키지를 활용하기에 적합한 SpringBoot위에서 채팅 서버를 적용할수 있을 뿐더러TCP 외에도 HTTP, UDP 같은 통신프로토콜을 적용한 채팅기능을 구현해 볼 수 있지 않을까? 기존 Back-End의 MVC 패턴구조에서 마이크로서비스아키텍처가 유행함에 따라 Reactor-Netty 서버는 꼭 알아야할 부분이며, 레퍼런스와 워크숍을 제공하고 있어 스타트가이드라인으로 많은 정보를 쉽게 얻을 수 있다. https://projectreactor.io/docs/netty/release/reference/index.html#about-doc https://violetagg.github.io/reactor-netty-workshop/#_tcp_server_and_client reactor-pattern을 이해하기위해 java.NIO를 참조해 간단한 앱을 제작하며 시스템구조와 동작과정을 이해할 수 있게되었다.언젠가, 귀차니즘을 물리치는 날이 온다면,java.NIO가 아닌 reactor.netty 패키지를 활용한 NIO 통신을 다뤄보고 이를 SpringBoot에 적용하여 HTTP와 TCP, UDP 다음의 3가지 통신을 유연하게 풀어내보고 싶다. 자료를 정리하다보니, 마침 SpringBoot-netty 에서의 채팅을 구현한 우아한리뷰가 있었다. 올려놓고 나중에 봐야지, https://woowabros.github.io/experience/2020/06/19/chat-app.html","link":"/2020/11/24/NIO-Chat/"},{"title":"SpringBoot Netty 서버에 SSL 적용기 2","text":"개요이번장은 SSL (Secure Socket Layer) 인증서를 발급받고 이를 도메인이 적용된 서버에 적용하는 과정을 담았다.SSL은 Certificate Authority(CA)라 불리는 서드 파티로부터 서버와 클라이언트간에 정보교환에 있어 암호를 적용한 방식을 말한다. SSL 개념정리 무료 SSL (Secure Socket Layer) 인증서 발급받기인증서의 유효기간이 3개월로 짧은대신 무료이다.현재 DNS 주소와 연결된 서버의 도메인명을 입력해 준다. 이후 “Create Free SSL Certificate” 클릭한다.무료 SSL sslforfree“Manual Verification” -&gt; “Manually Verify Domain” “Automatic FTP Verification” - FTP 를 이용한 자동 처리 방식 “Manual Verification” - 소유권 인증 파일을 다운로드받아 직업 업로드 “Manual Verification” - DNS에 TXT 레코드로 소유권 인증 키를 추가 다음의 3가지의 발급 방식이 있는데, 본인은 “Manual Verification”을 사용하였다.도메인명을 입력하고 인증을 받기 위한 파일을 자신의 웹서버에 직접 업로드하여 인증파일을 발급받는다.인증파일은 “Manually Verify Domain” 클릭하여 진행한다. Download the following verification files by clicking on each link below 하위 목록“Download File #1” , “Download File #2”를 받은 후, Verify successful upload by visiting the following links in your browser아래의 경로를 생성하여 다운로드 파일을 업로드한다..well-known/acme-challenge/다운로드파일#1 , #2 자신의 프로젝트 아래에 resources 폴더에 위치하고있다. path등록이미지 클릭 시 확대Sample-Project에 Controller는 생성이 되어있다. 자신의 Spring-boot 프로젝트의 Controller에 해당 파일을 SSL인증 발급을 위해 경로를 설정해줘야한다. 샘플프로젝트 - https://github.com/Kimbaro/springboot-sample.git 1234567891011121314151617181920212223// import import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.core.io.Resource;import org.springframework.http.MediaType;import org.springframework.stereotype.Controller;import org.springframework.web.reactive.function.server.RouterFunction;import org.springframework.web.reactive.function.server.ServerResponse;import static org.springframework.web.reactive.function.server.RequestPredicates.GET;import static org.springframework.web.reactive.function.server.RouterFunctions.route;import static org.springframework.web.reactive.function.server.ServerResponse.ok;//class field @Bean public RouterFunction&lt;ServerResponse&gt; sslforfree1(@Value(\"classpath:/.well-known/acme-challenge/&lt;인증서파일이름&gt;\") final Resource indexHtml) { return route(GET(\"/.well-known/acme-challenge/&lt;인증서파일이름&gt;\"), request -&gt; ok().contentType(MediaType.TEXT_PLAIN).syncBody(indexHtml)); } @Bean public RouterFunction&lt;ServerResponse&gt; sslforfree2(@Value(\"classpath:/.well-known/acme-challenge/&lt;인증서파일이름&gt;\") final Resource indexHtml) { return route(GET(\"/.well-known/acme-challenge/&lt;인증서파일이름&gt;\"), request -&gt; ok().contentType(MediaType.TEXT_PLAIN).syncBody(indexHtml)); } http://URL 포트포워딩SSL 검증을 위해 사이트에서 보여준 주소는 http 형식의 80포트이다. 파일 path를 잡아줬다해도 해당 사이트에서 접근하는 경로에 유의하여80포트 접근 시 8080포트로 Redirect할 필요가 있다.(본인 환경에 따라 포트는 다를 수 있음.) 리눅스의 iptables를 활용해 규칙을 만들어준다.80 포트 -&gt; 8080포트로 Redirect 1iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 포트포워딩설정 확인 1iptables -t nat -L --line-numbers 잘못된 입력으로 인한 iptables 삭제 필요 시 1iptables -t nat -D PREROUTING &lt;해당하는리스트번호입력&gt; 규칙이 올바름에도 접속이 안될경우 자신의 GCP환경의 방화벽규칙을 확인한다. 또는 리눅스 환경에서 방화벽 접근 허용 확인 인증서 발급아래의 “Download SSL Certificate” 클릭인증서 생성이 완료되었다. “Download All SSL Certificate Files” 클릭하여 파일을 받는다. 위 이미지와 같이 3개의 파일이 있어야 한다. ca_bundle.crt certificate.crt private.key 인증서 조합이제 해당 인증서를 조합하여 하나의 아카이브로 만들어야한다. 1openssl pkcs12 -export -out 생성할파일명.pfx -inkey private.key -in certificate.crt -certfile ca_bundle.crt 생성된 pfx 형식의 파일이 있다 해당 파일이 https://URL 형식의 접근을 위한 인증서이다. 인증서 적용서버에 자신의 SNAPSHOT 파일이 위치한 경로에 pfx형식의 자신의 인증서를 저장한다. Spring-Boot의 설정파일인 Application.yml에 server의 내용을 수정한다. 12345678server: port: 8445 #SSL 사용할 포트 지정 ssl: enabled: true key-store: certificate_trco.pfx key-store-type: PKCS12 key-store-password: 123456 # pfx 생성 시 설정한 패스워드 # key-alias: trco.site # (필요시) Alias 명 지정. CSR 자동 생성시에는 CN 명 클라우드 플랫폼 방화벽 규칙 등록GCP에 사용할 SSL포트를 허용해준다. 테스트해보자. 8445 포트로 정상 실행 확인https://URL인증서내용 https://URL 포트포워딩기본적으로 도메인 접근 시 http로 접근하며 임의로 사용자가 https를 명시해야만 SSL접속을 시작하기 때문에 다음의 포트 규칙이 필요하다.해당 포스팅에서 사용된 포트는 8445임에 주의한다. 80포트 -&gt; 443포트(서버파일에서설정)1234567891011121314151617181920//사용자 환경에 따른 수정이 필요함.//가능하면 OS의 iptables 규칙 443포트 리다이렉션 포트 설정을 요함.private int http_port = 80;private int https_port = 443;@Beanpublic void startRedirectServer() { NettyReactiveWebServerFactory httpNettyReactiveWebServerFactory = new NettyReactiveWebServerFactory(http_port); httpNettyReactiveWebServerFactory.getWebServer((request, response) -&gt; { URI uri = request.getURI(); URI httpsUri; try { httpsUri = new URI(\"https\", uri.getUserInfo(), uri.getHost(), https_port, uri.getPath(), uri.getQuery(), uri.getFragment()); } catch (URISyntaxException e) { return Mono.error(e); } response.setStatusCode(HttpStatus.MOVED_PERMANENTLY); response.getHeaders().setLocation(httpsUri); return response.setComplete(); }).start();} 자신의 Spring-boot netty의 Controller에 위 코드를 명시한다.80포트 (http-default) -&gt; 443 (https-default) 443포트 -&gt; 8445포트(운영체제 iptables)12iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8445iptables -t nat -L -–line-numbers 조회해 보니 이전에 인증서 파일발급을 위해 지정했던 80-&gt;8080규칙이 존재한다. 해당 규칙은 1번 line에 위치함을 알 수 있다.(사용자마다 다르니 참고)1iptables -t nat -D PREROUTING (해당하는리스트번호입력) 해당하는 라인을 삭제 후 다시 조회해본다. iptables -t nat -L -–line-numbers 이후 서버를 실행해 접속해보자.서버에선 80포트와 8445포트를 사용하며 80포트, 즉 http로 접근한 경우 linux iptables 규칙이 아닌 서버단에서 80포트-&gt;8445포트로 Redirect한다.만일 443포트, 즉 https로 접근한 경우 linux iptables 규칙에 의해 Redirect된다. 결과https 접근 http 접근 참고 무료 SSL 보안 인증서 발급받기 (Free SSL Certificate) SSL 인증서 변환 가이드","link":"/2019/09/11/SpringBoot-Netty-%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%E1%84%8B%E1%85%A6-SSL-%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%B52/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 2","text":"개요이전 포스팅은 SpringBoot를 로컬환경에서 배포해봤다. 이번엔 GCP의 Cloud Compute의 Ubuntu OS에서 SpringBoot를 배포를 위한 가상환경을 구성한다. 준비GCP의 가상머신 생성절차를 진행한다.컴퓨팅 - ComputeEngine - VM인스턴스 이후 아래의 이미지와 같이 본인이 원하는 서버를 구성하여 만들어줘야한다.여기서 본인은 아래 이미지와 같은 환경을 구성하였다. 이름 : 본인이 생성할 VM 인스턴스의 이름이다. 리전 : 가상머신을 실행할 서버의 위치이다. 머신구성 : 자신이 구성할 서버의 사양. 부팅디스크 : 서버를 구성할 OS. 방화벽 : 서버의 접근 방식이다. 초기 생성 시 적용할 프로토콜의 Default를 구성하는 값이다. 이제 해당 서버의 고정IP를 할당해준다.네트워킹 - VPC네트워크 - 외부 IP 주소 ‘유형=임시’ 를 ‘유형=고정’ 으로 변경해준다. ‘외부 접근허용을 위해’ 방화벽규칙을 적용한다.네트워킹 - VPC네트워크 - 방화벽 규칙 이름 : 본인이 생성할 방화벽 규칙의 이름이다. 우선순위 : 방화벽규칙에 적용될 우선순위이다. 사용환경에 따라 기본값을 달리하여 규칙을 적용할 수 있다. 대상 : 본인이 생성한 서버의 인스턴스를 대상으로 할것인지 여부를 묻는다. 소스 IP 범위 : 본인이 적용할 방화벽규칙의 IP 범위이다. 외부의 타 IP접근을 차단하거나 모두공개(0.0.0.0/0)할 수 있다. 프로토콜 및 포트 : 지정할 방화벽 규칙이다. 각 포트중 일부는 약속된 포트가 있으므로 개인의 포트를 적용할 땐 주의해야한다.다음 링크는 본인이 구성하는 기본 포트유형이다. 참고바란다.웹서버 기본 구성 포트 방화벽 규칙을 적용한 후 다음의 규칙이 적용되어 있어야한다. 8080 과 8443은 임의로 적용한 포트이며 각각 웹페이지 접근에 이용할 포트이다. ![](/images/Simple-springboot-tutorial2/5.png) GCP의 환경설정을 마무리하였다. 다음으로 외부에서 접근하기 위한 SSH키 생성 및 등록, 리눅스의 디렉토리 접근 권한을 변경해 FTP를 통해나의 VM에 파일을 전송한다.","link":"/2019/07/30/SpringBoot-Netty%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5-gradle-%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B52/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 3","text":"개요이전 단계에서 GCP활용을 위해 OS이미지설치와 접근을 위한 환경설정을 마무리 하였다. 이번 단계에서 FTP접근과 배포를 위한 Spring SNAPSHOT을 가상컴퓨터환경에 배포해본다. SSH 공개키 생성운영체제 : OS X윈도우인 경우 - 윈도우 SSH키 생성 맥의 경우 ssh-keygen프로그램이 내장되어 있으므로 command에 ‘ssh-keygen’을 입력해보자 1ssh-keygen 임의의 경로인 ‘/Users/dongyounkim/Documents/Me/생성할파일명’에 생성하였다. 패스워드는 생성할때 미입력 시 이후 더이상 묻지 않는다. - 생성된 개인키와 공개키 - 커멘드 cat생성된 키 내용을 들여다 보자 1cat 생성한파일명.pub GCP 환경설정에 공개키 내용을 기입한다. - GCP SSH키메타데이터 - SSH키 - 수정/항목추가*복사한 값의 마지막을 ‘띄어쓰기’ 후 명칭을 따로 입력해줘야함을 잊지말자. FTP접속맥의 경우 ftp클라이언트가 내장되어있어 따로 프로그램을 설치할 필요가 없으나 내장된 ftp프로그램은 읽기만 가능하다.이에 본인은 FileZila를 활용하였다. FileZila 개인키 등록접속을 위해 개인키를 등록해준다.설정 - 연결 - SFTP - 키 파일 추가 접속본인의 GCP의 생성된 VM인스턴스를 참고한다.본인의 설정정보에 맞게 FTP클라이언트에 입력한다.GCP SSH키에 등록한 값의 명칭을 사용자명으로 사용한다.IANA에서 할당한 SSH 프로토콜의 포트 : 22 를 사용한다.본인의 가상컴퓨터에 접근이 완료되었다.이제 배포할때이다.배포파일은 이전 글에서 볼 수 있다. 이전글 바로가기 SSH접속 FTP를 통한 전송과정에 앞서 접근권한을 설정해준다.이를 위해선 SSH환경의 원격접속이 필요하다. 맥환경에선 내장된 접속 프로그램이 있어 쉽게 접근이 가능하다. FTP접속을 위해 생성해둔 자신의 키파일 경로로 이동해 다음의 커맨드를 입력해준다. 1ssh -i 자신개인키 사용자명@호스트주소 * FTP 접속할때의 자신의 입력정보를 참고해보자 자신의 Spring SNAPSHOT 배포파일을 저장할 디렉토리의 경로 권한을 수정해준다.본인은 다음의 경로에 파일을 관리하고자한다. 1/usr/games/ - 관리자 계정 패스워드설정1sudo passwd root - 관리자 계정 접속1su root - 경로 권한 확인12cd /usr/games/ls -la - 사용자 생성 및 그룹추가12345sudo useradd 사용자명sudo passwd 사용자명usermod -aG 그룹명 사용자명cat /etc/group ‘cd /home’ 경로로 이동해 생성한 사용자명을 확인하고 해당하는 그룹에 추가한다.‘cat /etc/group’ 추가한 자신의 계정이 정상적으로 추가되었는지 확인한다. - 그룹권한 변경자신이 배포할 경로의 권한여부를 확인 후 필요에 따라 변경해준다.여기선 /usr/games/의 경로를 다루므로 다음의 경로의 권한을 변경해준다. 123cd /usr/games/mkdir serverchmod 771 server/ 생성한 ‘server’명의 디렉터리의 접근권한 중 root그룹에 속한 계정에게 권한을 부여해준다","link":"/2019/09/02/SpringBoot-Netty%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5-gradle%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B53/"},{"title":"JPA-Hibernate","text":"본문JPA를 요리하자. ORM(Object Relational Mapping)은 객체관계매핑으로 관계형데이터베이스(RDBMS)와 1:1 매핑관계를 이룬 방식이다.기존 JDBC의 비지니스 모델링 객체의 Entity는 DTO개념 그대로 DB와 Server간 데이터 교환만을 위해서 존재했다면,ORM 방식을 통한 Entity는 관계형데이터베이스의 Row 단위로 1:1 매핑을 이뤄 해당 Entity 자원만 가지고 있다면 쉽게 CRUD가 가능하다.신뢰할 수 있는 데이터 여부에 따라 영속성, 비영속성 관계로 부른다. ORM 방식 중 JAVA에서 차용한 기술명세가 JPA이다.해당 ORM 프레임워크중 대표적인 것은 다음과 같다. JPA(Java Persistence Api) Hibernate EclipseLink DataNucleus SpringBoot는 Hibernate를 기본 제공자로 구성하기 때문에 이를 기반으로 JPA를 작성하도록 만든 Repository가 있다. ‘org.springframework.boot:spring-boot-starter-data-jpa’ 해당 주소를 gradle에 적용만 해준다면 알아서 Initialize해준다. 우리는 data-jpa를 활용해 개발에만 집중할 수 있어 친절하다. Hibernate를 간단하게 이용해보자.,#참고하면 도움 될 주소, (이미지출처)Hibernate Document Link 위 주소의 userguide에서 가져온 관계도이다. Hibernate는 다음의 객체를 제공한다. 클래스 내용 SessionFactory (org.hibernate.SessionFactory) SessionFactory는 말 그대로 Session생성하기 위한 공장이다. 사용자 요청에 따라 수십 수만개의 Session을 생성한다. 어플리케이션 전체 접근자는 이 하나의 객체를 공유한다. Session (org.hibernate.Session) 우리는 Session의 구현체인 EntityManager를 다룰것이다. 이는 단일 스레드로 동작하며 JDBC를 내부에 포함하고 있어 DB와 Connection 역할을 담당한다. Transaction (org.hibernate.Transaction) EntityTransaction은 Connection된 이후 트랜잭션 영역을 관리한다. 0. Requirements본 포스팅은 다음과 같은 환경임. Build Version Springboot 2.2.5.RELEASE Gradle 6.2.2 Dependencies(implementation) org.springframework.boot:spring-boot-starter-data-jpa org.springframework.boot:spring-boot-starter-web org.springframework.boot:spring-boot-starter-data-jdbc Dependencies(compileOnly) org.projectlombok:lombok Dependencies(runtimeOnly) com.oracle.ojdbc:ojdbc8 Dependencies(testCompile) junit:junit:4.12 DBMS Oracle Database 11g Standard Edition One(se1) IDE Build Tool IntelliJ IDEA 1. datasource 작성 및 DDL설정Springboot 2.0 이상부턴 DBCP를 사용하지 않는다. HikariCP를 default로 사용하며 기존 datasource 설정은 그대로 사용하되 나머지 Pool에 대한 설정은HikariCP가 담당한다.* DBCP2와 HikariCP 성능분석 보러가기 path : resources/application.yml12345678910111213141516171819202122spring: datasource: driver-class-name: oracle.jdbc.OracleDriver url: jdbc:oracle:thin:@&lt;URL&gt;:&lt;PASSWORD&gt;/&lt;USERNAME&gt; username: &lt;USERNAME&gt; password: &lt;PASSWORD&gt; hikari: connection-timeout: 30000 maximum-pool-size: 5 minimum-idle: 5 validation-timeout: 5000 idle-timeout: 600000 max-lifetime: 1800000 leak-detection-threshold: 0 jpa: hibernate: ddl-auto: update show-sql: true generate-ddl: true * hikariCP의 각 속성정보는 다음의 포스팅을 참고하였음.* DDL 설정관련 다음 포스팅 참고하였음. jpa.hibernate.ddl-auto none: 아무것도 실행하지 않는다 (대부분의 DB에서 기본값이다) create-drop: SessionFactory가 시작될 때 drop및 생성을 실행하고, SessionFactory가 종료될 때 drop을 실행한다 (in-memory DB의 경우 기본값이다) create: SessionFactory가 시작될 때 데이터베이스 drop을 실행하고 생성된 DDL을 실행한다. update: 변경된 스키마를 적용한다. validate: 변경된 스키마가 있다면 변경점을 출력하고 애플리케이션을 종료한다. jpa.hibernate.show-sql true, false : DB에 전달한 쿼리를 로그에 띄울지 여부를 결정한다. jpa.hibernate.generate-ddl true, false : jpa.hibernate.dll-auto 옵션을 사용할 것인지 여부를 결정한다. JPA를 활용한다면 DB에 접근해 일일이 DDL을 보내지 않고도 쉽게 생성이 가능하다. 단, ddl-auto의 value값의 내용을 보면 알 수 있듯 잘못하다간 기존 적용하여 사용중인DB를 날리는 수 있으니 다양한 테스트케이스를 확인할때만 해당 기능을 활용하는 것이 좋을 것이다. 2. 자동기본키 매핑JPA 기본키 매핑 JPA Primary Key Automatic Primary Key Application Set Primary Key Composite Primary Key Embedded Primary Key Obtaining the Primary Key 해당 포스트는 @GeneratedValue 를 적용해 Oracle의 자동증가 시퀸스를 활용한 Automatic Primary Key 매핑을 다뤄본다. Domain 객체 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.kimbaro.test.demo.domain;import lombok.Builder;import lombok.Data;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.UpdateTimestamp;import javax.persistence.*;import javax.validation.constraints.NotNull;import java.io.Serializable;import java.sql.Timestamp;@Entity@Data@Table( name = \"USER_INFO_DB\", uniqueConstraints = {@UniqueConstraint( name = \"USER_INFO_UNIQ\", columnNames = {\"NICKNAME\"})}, indexes = {@Index( name = \"USER_INFO_IDX\", columnList = \"NICKNAME,NAME\")})@SequenceGenerator( name = \"USER_INFO_SEQ\", sequenceName = \"USER_INFO_SEQ_1\", allocationSize = 2, initialValue = 1)public class USER_INFO implements Serializable { @Id @GeneratedValue( strategy = GenerationType.SEQUENCE, generator = \"USER_INFO_SEQ\") private long ID; @Column(name = \"NICKNAME\") @NotNull private String NICKNAME; @Column(name = \"NAME\") @NotNull private String NAME; @Column(name = \"GENDER\") @NotNull private char GENDER; @Column(name = \"AGE\") @NotNull private int AGE; @Column(name = \"CREATE_DATE\") @CreationTimestamp private Timestamp CREATE_DATE; @Column(name = \"LOGIN_DATE\") @UpdateTimestamp private Timestamp LOGIN_DATE; @Builder public USER_INFO(String NICKNAME, String NAME, char GENDER, int AGE) { this.NICKNAME = NICKNAME; this.NAME = NAME; this.GENDER = GENDER; this.AGE = AGE; } public USER_INFO() { }} @SequenceGenerator의 설정에 의해 “MY_FAVOLITE_SEQ_1” 이란 시퀸스가 생성될 것이다.@CreationTimestamp는 해당 Entity를 insert하는 경우 현재 시간을 반영하며, @UpdateTimestamp는 해당 id의 Entity가 DB와 매핑될때마다 그 시간대를 update한다.* 각 Annotation의 상세한 내용은 해당 링크를 참고하도록 한다. 이후 빌드 후 DB에 연결하여 내용을 보면 해당 테이블과 설정된 키 정보가 생성되어 있다. ddl-auto의 값이 update이고 서버를 빌드할때마다 show-sql:true로 인해 db에 어떤 쿼리를 전달하는지 로그에 작성되어 있을 것이다.해당 설정 정보가 DB서버와 다르다면 Entity에 적용된 설정으로 DB서버에 반영되므로 이에 주의하여 상황에 따라 ddl-auto의 값을 변경해줘야 한다. 3. Persistence Context 설계자바 ORM표준 JPA프로그래밍 김영환 (저자) 를 참고하면 다음과 같이 설명하고 있다.”Persistence Context”는 “영속성 컨텍스트”로 엔티티를 영구 저장하는 환경이다.JPA에서 엔티티의 생명주기에 따라 다음과 같이 4가지 상태가 존재하는데 비영속 영속 준영속 삭제 각각의 상태에 따라 엔티티가 어떻게 이루는지 테스트 케이스를 작성하며 알아본다. 4. Test case 작성Transaction처음 언급했던 Hibernate가 제공하는 EntityManagerFactory, EntityManager, EntityTransaction과 서비스로직을 작성해 hibernate_save()실행해본다. 12345678910111213141516171819202122232425262728@Testpublic void hibernate_save() { EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); try { transaction.begin(); //트랜잭션 시작 //서비스 로직 동작 영역 save(em); transaction.commit(); //트랜잭션 커밋 } catch (Exception e) { transaction.rollback(); //트랜잭션 롤백 e.printStackTrace(); }}@Testpublic void save(EntityManager em) throws Exception{ USER_INFO user_info = new USER_INFO().builder() .NICKNAME(\"kimbaro\") .NAME(\"HongGilDong\") .AGE(11).GENDER('남') .build(); em.persist(user_info);} table을 조회하니 Entity 객체에 대입한 값과 동일하게 매핑이 되어 있다. 비영속상태23~28 Line을 보면 USER_INFO 라는 Entity객체가 초기화 되는 과정이 담겨있는데 해당 구간에서 USER_INFO에 대입된 값은 식별자(ID값)가 없는 상태이다. 영속상태이후 em.persist() 메서드를 불러오는데 이 경우 USER_INFO를 DB에 보내기 위한 식별자(ID)를 할당한 상태이다. 해당 객체 정보는 아직 DB에 저장된 상태는 아니지만EntityManager가 관리하는 1차 캐시에 올라간 상태이다. 정상적으로 영속상태 인지 여부는 EntityManager.contains를 통해 확인해 볼 수 있다. 준영속상태에서 영속상태로 병합persist()메서드를 통한 EntityManager 의 캐시에 객체가 담긴 경우 식별자 값이 해당 객체에 할당된다. 이후 EntityManager의 캐시에서분리된다면 이를 준영속 상태라 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.kimbaro.test.demo;import com.kimbaro.test.demo.domain.USER_INFO;import org.junit.Assert;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.persistence.*;import javax.transaction.Transactional;@SpringBootTestclass DemoApplicationTests { // 서버 빌드 시 초기화된 팩토리 객체를 불러온다. // persistence unit의 name을 지정 하지 않은경우 default // 팩토리는 서버를 빌드하며 초기화를 진행한다. @PersistenceUnit private EntityManagerFactory emf; @Test @Transactional public void hibernate_save() { EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); USER_INFO user_info = new USER_INFO().builder() .NICKNAME(\"kimbaro_5\") .NAME(\"HongGilDong\") .AGE(11).GENDER('남') .build(); try { transaction.begin(); //트랜잭션 시작 /* 서비스 로직 동작 영역 */ save(user_info, em); transaction.commit(); //트랜잭션 커밋 em.close(); // EntityManager 에 담긴 캐시를 모두 제거 } catch (Exception e) { transaction.rollback(); //트랜잭션 롤백 e.printStackTrace(); } em = emf.createEntityManager(); transaction = em.getTransaction(); try { transaction.begin(); /* 서비스 로직 동작 영역 */ save_merge(user_info, em); transaction.commit(); em.close(); // EntityManager 에 담긴 캐시를 모두 제거 } catch (Exception e) { transaction.rollback(); e.printStackTrace(); } } @Test public void save(USER_INFO user_info, EntityManager em) throws Exception { Assert.assertFalse(\"비영속상태, 식별자 값이 할당되어 있지 않음.\" , em.contains(user_info)); em.persist(user_info); //EntityManager에 객체 전달 Assert.assertTrue(\"영속상태, 식별가 값이 할당되어 있고 1차 캐시에 올라간 상태.\" , em.contains(user_info)); System.out.println(\"영속상태 할당받은 식별자 값 em.persist() : \" + user_info.getID()); //준영속상태(분리) //EntityManager에 저장된 캐시에 user_info 변수의 객체를 분리시킴. em.detach(user_info); Assert.assertFalse(\"준영속상태, 식별자값 할당 되어 있으나 캐시에 분리된 상태\" , em.contains(user_info)); //detached된 상태 이므로 최종적으로 DB에 값이 저장되지 않음. } @Test public void save_merge(USER_INFO user_info, EntityManager em) throws Exception { user_info.setNICKNAME(\"GamJaDa2\"); Assert.assertFalse(\"준영속상태, 식별자값 할당 되어 있으나 캐시에 분리된 상태\" , em.contains(user_info)); user_info = em.merge(user_info); //병합 System.out.println(\"영속상태, 병합 후 자동기본키 매핑으로 기본키 값이 변환됨. : \" + user_info.getID()); Assert.assertTrue(\"영속상태, 식별가 값이 할당되어 있고 1차 캐시에 올라간 상태.\" , em.contains(user_info)); }} 해당 코드를 보면 em.detach() 메서드를 통해 분리시킴을 알 수 있다. 분리된 상태에선 DB에 값이 조회되지 않는다.분리된 객체는 em.marge()를 통해 다시 병합하여 EntityManager의 캐시에 등록되고 마지막 커밋으로 DB에 insert된다.","link":"/2020/03/19/JPA-Hibernate/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 1","text":"개요본 내용은 gradle환경의 SpringBoot-Netty서버를 GCP의 Ubuntu에 배포하고 이후 SSL을 적용한 https 환경을 구성하는 내용이다.localhost 에서 동작 가능한 Gradle 환경의 Simple SpringBoot-Netty 서버는 MSA를 기반으로 두고 있다.본 예제의 프로젝트는 다음의 깃 경로에 배포한다. https://github.com/Kimbaro/springboot-sample.git 배포용 snapshot을 생성한다.해당 프로젝트 경로의 터미널에서 다음의 커맨드를 입력한다. 12./gradlew clean./gradlew build ./gradlew clean은 빌드전에 디렉토리와 그래들 환경을 초기화한다../gradlew build는 배포를 위한 snapshot을 생성한다. build/libs 아래에 (프로젝트명)-0.0.1-SNAPSHOT.jar 의 디렉토리와 jar 파일의 생성을 확인 할 수 있다.이제 해당 경로에서다음의 커맨드를 입력한다. 이후 성공적으로 빌드가 되는지 여부를 확인해본다.로그는 다음과 같이 8080 PORT로 서버가 실행중임을 알 수 있다. 1java -jar (프로젝트명)-0.0.1-SNAPSHOT.jar 로컬환경에서 배포가 완료되었다면 다음으로 GCP의 Cloud Computing 에서 Ubuntu를 설치하고위와같이 배포하려한다.","link":"/2019/07/30/SpringBoot-gradle%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%E1%84%8B%E1%85%A6-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 4","text":"개요이전글에서 파일 배포까지 완료되었다 해당 파일을 실행하여 접속해보자 배포스프링서버 배포를 위해선 java가 설치되어 있어야 한다.해당 링크를 참고하여 설치하자 리눅스우분투자바설치 저장된 배포파일로 이동하여 다음의 커맨드를 입력한다.로그를 보면 8080 포트로 현재 서버가 실행 중 임을 알리고 있다. 1java -jar 배포파일.jar 접속해보자 자신의 ‘아이피주소:8080’ 형태의 주소로 이뤄져있다. nohup 적용ssh 터미널 종료 시 java -jar로 실행된 서버또한 종료되는데 해당 프로세스의 종료를 막기위해 nohup을 활용한다. - 쉘 스크립트 생성 및 실행nohup은 쉘 스크립트 파일을 실행한다. java -jar 명령어를 쉘 스크립트 파일에 입력해야한다. 1vim start-server.sh 자신의 .jar 배포파일을 입력해주자 생성된 쉘 스크립트를 실행한다. 1nohup ./start-server.sh 만일 Permission 문제가 발생한다면 쉘스크립트와 스냅샷 파일의 권한을 변경해보자 - 프로세스 동작 확인1netstat -lntp | grep 포트번호 - ps서버단에서의 System.out.println 같은 출력문은 ‘nohup.out’에 로그가 남으니 참고.","link":"/2019/09/02/SpringBoot-Netty%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5-gradle%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B54/"},{"title":"Spring Data JPA","text":"writting..","link":"/2020/03/22/SpringData-JPA/"},{"title":"Well-Known Port 정리","text":"0번 ~ 1023번 : 잘 알려진 포트(Well-Known Port)특정한 쓰임새를 위해서 IANA에서 할당한 TCP 및 UDP 포트 번호의 일부이다. 참고용 포트 TCP/UDP 설명 0 UDP 예약됨; 사용하지 않음 20 TCP FTP (파일 전송 프로토콜) - 데이터 포트 21 TCP FTP - 제어 포트 22 TCP SSH (Secure Shell) - ssh scp, sftp같은 프로토콜 및 포트 포워딩 53 TCP/UDP DNS (Domain Name System) 80 TCP/UDP HTTP (HyperText Transfer Protocol) - 웹 페이지 전송 443 TCP HTTPS - SSL 위의 HTTP (암호화 전송)","link":"/2019/08/05/Well-Known-Port-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5/"},{"title":"안드로이드 BLE 통신","text":"개요구글이 깃에 올려둔 Sample project 중에서 블루투스 BLE의 코드는 API21 이상의 버전과 호완성 문제를 보인다.타겟을 21로 낮추면 되겠지만 앱을 플레이스토어에 배포하기 위해선 정책이 바뀌어 API28(Android Pie)이상을 타겟으로 잡아야한다.이로인한 문제는 다음과 같고 필수적으로 변경시켜야한다. BluetoothAdapter 클래스의 stopLeScan 과 startLeScan 을 지원하지 않는다.BluetoothLeScanner 클래스를 사용한 stopScan, startScan 두 메서드를 사용해야한다. 블루투스 통신에 있어서 위치권한과 GPS를 함께 사용한다.갤럭시S8 기기에서 테스트 했었는데, 위치권한 뿐 아니라 GPS가 켜있어야 함을 알 수 있었다.https://stackoverflow.com/questions/33043582/bluetooth-low-energy-startscan-on-android-6-0-does-not-find-devices/33045489#33045489 구글이 제공한 기존의 샘플은 다음과 같다.https://github.com/googlesamples/android-BluetoothLeGatt.git 위 문제에 따른 수정본은 다음과 같다.https://github.com/Kimbaro/android-BluetoothLeGatt-API28.git Pre-requisites 이름 버전 설명 Android SDK 28 - Android Build Tools v28.0.3 - 리뷰변경점, BluetoothLeScanner 관련BluetoothAdapter클래스를 대신해 BluetoothLeScanner를 추가 12345678910111213141516private LeDeviceListAdapter mLeDeviceListAdapter; private boolean mScanning; private Handler mHandler; //추가 API21 이상부터 스캔을 위해선 다음의 클래스 사용 private BluetoothLeScanner mBLEScanner; private BluetoothAdapter mBluetoothAdapter; private static final int REQUEST_ENABLE_BT = 1; private static final int MY_PERMISSIONS_REQUEST = 2; 이하내용생략 . . . BluetoothAdapter의 스캔기능은 사용하지 않으나 Adapter 본연의 역할은 수행하고 있다.onCreate()에서 BluetoothManager의 정보를 getAdapter()를 선언하여 BluetoothAdapter에 제공하고 이 블루투스 정보를 BluetoothLeScanner 객체에 전달하고 있다. 결론으로 전체적인 흐름은 다음과 같다.*BluetoothManager =&gt; BluetoothAdapter =&gt; BluetoothLeScanner =&gt; 스캔기능 수행 * 12345678910111213141516171819202122232425262728private BluetoothLeScanner mBLEScanner;private BluetoothAdapter mBluetoothAdapter;@Override public void onCreate(Bundle savedInstanceState) { . . . 위내용생략 final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = bluetoothManager.getAdapter(); // Checks if Bluetooth is supported on the device. if (mBluetoothAdapter == null) { Toast.makeText(this, R.string.error_bluetooth_not_supported, Toast.LENGTH_SHORT).show(); finish(); return; } //추가 mBLEScanner = mBluetoothAdapter.getBluetoothLeScanner(); // Checks if Bluetooth LE Scanner is available. if (mBLEScanner == null) { Toast.makeText(this, \"Can not find BLE Scanner\", Toast.LENGTH_SHORT).show(); finish(); return; } } 변경점, BLE통신 콜백 클래스 변경BluetoothAdapter의 스캔기능이 지원되지 않으면서 그에따라 BluetoothAdapter.LeScanCallback 또한 사용하지 않는다.LeScanCallback은 interface로 단독적으로 오버라이딩하였으나 BluetoothLeScanner에 사용되는 콜백클래스인 ScanCallback은 Object를 상속받는 abstract 추상객체로 이뤄져있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 private ScanCallback mScanCallback = new ScanCallback() { @Override public void onScanResult(int callbackType, ScanResult result) { super.onScanResult(callbackType, result); processResult(result); } @Override public void onBatchScanResults(List&lt;ScanResult&gt; results) { super.onBatchScanResults(results); for (ScanResult result : results) { processResult(result); } } @Override public void onScanFailed(int errorCode) { super.onScanFailed(errorCode); } private void processResult(final ScanResult result) { runOnUiThread(new Runnable() { @Override public void run() { mLeDeviceListAdapter.addDevice(result.getDevice()); mLeDeviceListAdapter.notifyDataSetChanged(); } }); } }; // 사용하지 않음.// private BluetoothAdapter.LeScanCallback mLeScanCallback =// new BluetoothAdapter.LeScanCallback() {//// @Override// public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {// runOnUiThread(new Runnable() {// @Override// public void run() {// mLeDeviceListAdapter.addDevice(device);// mLeDeviceListAdapter.notifyDataSetChanged();// }// });// }// }; 추가, GPS의 사용블루투스 기능을 사용하기 위해선 위치권한 허용 뿐만 아니라 해당 GPS가 켜있어야한다. 그렇지 않으면 기능사용이 불가하므로 이를 방지한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//AlertDialog private void alertCheckGPS() { AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage(\"GPS를 허용해 주셔야 앱 이용이 가능합니다.\") .setCancelable(false) .setPositiveButton(\"GPS 설정\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { moveConfigGPS(); } }) .setNegativeButton(\"취소\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { dialog.cancel(); restart(); } }); AlertDialog alert = builder.create(); alert.show(); } // GPS 설정화면으로 이동 private void moveConfigGPS() { Intent gpsOptionsIntent = new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS); startActivityForResult(gpsOptionsIntent, MY_PERMISSIONS_REQUEST); } //재시작 public void restart(){ Intent i = getBaseContext().getPackageManager(). getLaunchIntentForPackage(getBaseContext().getPackageName()); i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(i); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { // User chose not to enable Bluetooth. if (requestCode == REQUEST_ENABLE_BT &amp;&amp; resultCode == Activity.RESULT_CANCELED) { finish(); return; } if (requestCode == MY_PERMISSIONS_REQUEST) { if (!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) { Toast.makeText(getApplicationContext(), \"GPS가 꺼져있습니다.\", Toast.LENGTH_LONG).show(); //앱 재실행 restart(); } } super.onActivityResult(requestCode, resultCode, data); }@Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getActionBar().setTitle(R.string.title_devices); locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); //버전체크 if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) || (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED)) { ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, MY_PERMISSIONS_REQUEST); } //GPS 설정여부 if(!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)){ alertCheckGPS(); } 이하내용생략 . . . 마무리안드로이드 API23을 타겟으로 앱 개발했다가 큰 낭패를 보았다. 막상 만들꺼 다 만들어놓고 배포하자니 API28이상만 배포 가능하다고하니..삽질을 많이 해버렸다.","link":"/2019/09/02/%E1%84%8B%E1%85%A1%E1%86%AB%E1%84%83%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3-BLE-%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB/"},{"title":"안드로이드 Classic 통신","text":"개요안드로이드 Classic통신은 블루투스 3.0 이하의 버전을 말하며, 블루투스 4.0 이상은 BLE통신을 뜻한다.블루투스 4.0이상의 모듈은 그 하위 버전을 포함하기도한다. 여기서 알아볼 것은 Classic한 블루투스 통신인 Socket통신이다.안드로이드는 Android Bluetooth API를 통해 블루투스 기능에 관한 엑세스 권한을 제공한다. 이 글에서 제공하는 내용은 아래와 같은 과정의 Sample Project이다 페어링된 블루투스 기기에 대한 로컬 블루투스 어댑터 쿼리 RFCOMM 채널 설정 블루투스 기기의 데이터 수신 블루투스에 관한 자세한 정보는 Document를 참고하자.https://developer.android.com/guide/topics/connectivity/bluetooth?hl=ko 해당 내용에 따른 Sample Project는 다음과 같다.https://github.com/Kimbaro/android-BluetoothClassicProtocol-Sample Pre-requisites 이름 버전 설명 Android SDK 28 - Android Build Tools v28.0.0 - 리뷰블루투스 기능 사용을 위한 권한은 다음과 같다. 123456789&lt;manifest&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; 이하내용생략 . . . 패키지 구조블루투스체크 -&gt; 기기연결 과정을 두 클래스로 나눠 진행하고 디바이스정보를 담고있는 Device클래스를 포함한다.util.BT_check , util.BT_connect , util.Device util.BT_check인스턴스를 불러오는 방법은 간단하다. 사용자가 위치한 activity , 블루투스 수신받은 데이터를 보여주기 위한 textView,상황에 따라 textView를 다른 아이템으로 바꿔 사용 할 수 있겠다. 여기서 BT_check 클래스는 그 activity와 textView를 인자로 전달받아 초기화한다. 12345678910111213141516171819public class MainActivity extends AppCompatActivity {Button button = null; TextView textView = null; Activity activity = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); activity = this; button = findViewById(R.id.bt1); textView = findViewById(R.id.tv1); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { BT_check bt_check = new BT_check(activity, textView); bt_check.checkBluetooth(); util.BT_check.checkBluetooth()블루투스 소켓 통신을 위한 메서드이며 블루투스의 전체적인 정보가 담긴 어댑터인 BluetoothAdapter를 생성하고정상적으로 블루투스가 동작하는지 통신하기전 기기를 체크한다. 123456789101112131415161718192021222324public class BT_check { private BluetoothAdapter mBluetoothAdapter = null; private Activity activity = null; private TextView textView; public void checkBluetooth() { mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (mBluetoothAdapter == null) { // 장치가 블루투스 지원하지 않는 경우 Toast.makeText(activity.getApplicationContext(), \"해당 모바일은 블루투스를 지원하지 않음\", Toast.LENGTH_SHORT).show(); } else { // 장치가 블루투스 지원하는 경우 if (!mBluetoothAdapter.isEnabled()) { // 블루투스를 지원하지만 비활성 상태인 경우 // 블루투스를 활성 상태로 바꾸기 위해 사용자 동의 요첨 Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); activity.startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); } else { // 블루투스를 지원하며 활성 상태인 경우 // 페어링된 기기 목록을 보여주고 연결할 장치를 선택. selectDevice(); } } } util.BT_check.selectDevice()페어링된 기기목록을 보여주고 연결할 장치를 선택한다. 해당 페어링 목록은 두 기기간의 연결프로세스가 성립되어 또는 성립된적이 있어서 언제든 사용할 수 있도록 디바이스가 캐싱해둔 페어링 목록을 뜻한다. 목록은 AlertDialog를 통해 띄워준다.만일 사용자가 페어링 기기를 찾아 선택했다면 블루투스디바이스와의 연결을 위한 BT_connect.class를 호출한다 해당 객체의 생성자는 다음의 인자를 받아 초기화한다.** 사용자가 위치한 액티비티, 검색된 블루투스목록, 블루투스어댑터 , 데이터가입력될 textView ** 결과적으로 BT_check.class에서 얻어온 정보를 BT_connect.class로 전달한다고 보면 된다. 12345678910111213141516171819202122232425262728293031323334353637383940Set&lt;BluetoothDevice&gt; mDevices; int mPairedDeviceCount; private void selectDevice() { //페어링되었던 기기 목록 획득 mDevices = mBluetoothAdapter.getBondedDevices(); //페어링되었던 기기 갯수 mPairedDeviceCount = mDevices.size(); //Alertdialog 생성(activity에는 context입력) AlertDialog.Builder builder = new AlertDialog.Builder(activity); //AlertDialog 제목 설정 builder.setTitle(\"등록된 디바이스\"); 이하내용생략 . . . builder.setItems(items, new DialogInterface.OnClickListener() { // 리스트 아이템 클릭 이벤트 @Override public void onClick(DialogInterface dialog, int which) { Dialog dialog_ = (Dialog) dialog; // 연결할 장치를 선택하지 않고 '취소'를 누른 경우 if (which == listItems.size() - 1) { Toast.makeText(dialog_.getContext(), \"취소\", Toast.LENGTH_SHORT).show(); } else { //취소가 아닌 디바이스를 선택한 경우 해당 영역 실행 Toast.makeText(dialog_.getContext(), \"선택 장치명 : \" + items[which].toString(), Toast.LENGTH_SHORT).show(); setDeviceName(items[which].toString()); //타겟 액티비티 ,블루투스 검색 목록 , 검증된 블루투스 정보, 받아온 값 입력대상 BT_connect bt_connect = new BT_connect(activity, getMDevices(), getMBluetoothAdapter(), textView); //본인이 선택한 블루투스이름 bt_connect.connectToSelectedDevice(getDeviceName()); } } }); util.BT_connect모든 준비가 끝났다. BT_check.class에서 생성된 데이터로 BT_connect.class가 구성되어있다. 그 외에도 소켓통신 및 이를 위한 스트림 객체등통신 및 데이터를 처리하기위한 객체가 선언되어있다. 1234567891011121314151617181920212223242526272829303132public class BT_connect { BluetoothSocket mSocket; InputStream mInputStream; OutputStream mOutputStream; Activity activity; BluetoothDevice mRemoteDevice; Set&lt;BluetoothDevice&gt; mDevices; BluetoothAdapter mBluetoothAdapter; byte[] readBuffer; //수신 데이터 int readBufferPositon; //버퍼 내 수신 문자 저장 위치 Thread mWorkerThread; byte mDelimiter = 10; private BT_connect() { } //데이터 출력 테스트용 TextView textView; Button button; public BT_connect(Activity activity, Set&lt;BluetoothDevice&gt; mDevices, BluetoothAdapter mBluetoothAdapter, TextView textView) { this.activity = activity; this.mDevices = mDevices; this.mBluetoothAdapter = mBluetoothAdapter; this.textView = textView; button = this.activity.findViewById(R.id.bt1); } 이하내용생략 . . . util.BT_connect.connectToSelectedDevice()블루투스 데이터를 실시간으로 받기위해선 스레드가 필요하다. 스트림 객체는 Handler를 통해 생성하며 BluetoothSocket.getOutputStream() , BluetoothSocket.getInputStream() 두 메서드 선언으로 스트림이 연결된다.소켓 Connect 상황에 따라 Handler에 다음의 값을 보내 상황에 따른 이벤트가 발생한다. 1인 경우 연결에 성공하여 스트림을 생성하는 단계 -1인 경우 연결에 오류가 있어 소켓을 close하는 단계 연결에 성공한 경우 데이터 수신을 처리하는 beginListenForData()를 실행한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859...위내용생략 public void connectToSelectedDevice(final String selectedDeviceName) { button.setText(\"연결중 기다려주세요\"); //handler는 thread에서 던지는 메세지를 보고 다음 동작을 수행시킨다. final Handler mHandler = new Handler() { public void handleMessage(Message msg) { if (msg.what == 1) // 연결 성공 { try { //블루투스 기기와의 소켓통신을 위한 커넥션 실행 mOutputStream = mSocket.getOutputStream(); mInputStream = mSocket.getInputStream(); // 데이터 수신 리스너 beginListenForData(); button.setText(\"연결 성공\"); } catch (IOException e) { e.printStackTrace(); } } else { //연결 실패 Toast.makeText(activity, \"연결실패! 연결상태를 확인해주세요\", Toast.LENGTH_SHORT).show(); try { mSocket.close(); button.setText(\"연결 실패\"); } catch (IOException e) { e.printStackTrace(); } } } }; //연결과정을 수행할 thread 생성 Thread thread = new Thread(new Runnable() { public void run() { //선택된 기기의 이름을 갖는 bluetooth device의 object mRemoteDevice = getDeviceFromBondedList(selectedDeviceName); UUID uuid = Device.DEVICE_UUID; try { // 소켓 생성 mSocket = mRemoteDevice.createRfcommSocketToServiceRecord(uuid); // RFCOMM 채널을 통한 연결, socket에 connect하는데 시간이 걸린다. 따라서 ui에 영향을 주지 않기 위해서는 // Thread로 연결 과정을 수행해야 한다. mSocket.connect(); mHandler.sendEmptyMessage(1); } catch (Exception e) { // 블루투스 연결 중 오류 발생 mHandler.sendEmptyMessage(-1); } } }); //연결 thread를 수행한다 thread.start(); } util.BT_connect.beginListenForData()블루투스 커넥션을 위한 해당 스레드과정에서, beginListenForData()에서 데이터를 받아 처리하기 위한 스레드가 한번더 실행된다.Queue방식으로 블루투스기기로 부터 데이터를 수신하여 handler.post에서 데이터 처리 이벤트를 진행한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//블루투스 수신 리스너 protected void beginListenForData() { final Handler handler = new Handler(); readBuffer = new byte[1024]; readBufferPositon = 0; mWorkerThread = new Thread(new Runnable() { @Override public void run() { while (!Thread.currentThread().isInterrupted()) { try { int bytesAvailable = mInputStream.available(); if (bytesAvailable &gt; 0) { //데이터가 수신된 경우 byte[] packetBytes = new byte[bytesAvailable]; mInputStream.read(packetBytes); for (int i = 0; i &lt; bytesAvailable; i++) { byte b = packetBytes[i]; if (b == mDelimiter) { byte[] encodedBytes = new byte[readBufferPositon]; System.arraycopy(readBuffer, 0, encodedBytes, 0, encodedBytes.length); final String data = new String(encodedBytes, \"US-ASCII\"); readBufferPositon = 0; handler.post(new Runnable() { public void run() { //===== 데이터 정상 수신 영역 ===== //수신된 데이터는 data변수에 의해 String형 변환되어 있음. textView.setText(data); } }); } else { readBuffer[readBufferPositon++] = b; } } } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } }); //데이터 수신 thread 시작 mWorkerThread.start(); }} 마무리해당 통신과정은 위에서 언급했듯이 Classic한 통신방법으로 기존 블루투스 3.0방식의 모듈에서 많이 활용된다.모바일에서의 동작에 있어 안드로이드 버전에 따른 여러 제약사항이 BLE에 비해 크게 변경된 사항은 없다. 그냥 돌아다니는거 써도 될 정도로.. 인턴십때문에 현장에서 스마트밴드와 호흡기측정기를 블루투스통신 하는 과정이 있었는데 덕분에 BLE와 Socket통신을 실제업무에서 적용해 볼 수 있는 기회라 참 재밌었다.","link":"/2019/09/05/%E1%84%8B%E1%85%A1%E1%86%AB%E1%84%83%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3-Socket%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB/"}],"tags":[{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"Entity","slug":"Entity","link":"/tags/Entity/"},{"name":"Springboot","slug":"Springboot","link":"/tags/Springboot/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"스프링부트","slug":"스프링부트","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"Https","slug":"Https","link":"/tags/Https/"},{"name":"Carla-Simulator","slug":"Carla-Simulator","link":"/tags/Carla-Simulator/"},{"name":"Autonomous","slug":"Autonomous","link":"/tags/Autonomous/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"chatting","slug":"chatting","link":"/tags/chatting/"},{"name":"채팅","slug":"채팅","link":"/tags/%EC%B1%84%ED%8C%85/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"배포","slug":"배포","link":"/tags/%EB%B0%B0%ED%8F%AC/"},{"name":"GCP","slug":"GCP","link":"/tags/GCP/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"ORM","slug":"ORM","link":"/tags/ORM/"},{"name":"Hibernate","slug":"Hibernate","link":"/tags/Hibernate/"},{"name":"잘 알려진 포트","slug":"잘-알려진-포트","link":"/tags/%EC%9E%98-%EC%95%8C%EB%A0%A4%EC%A7%84-%ED%8F%AC%ED%8A%B8/"},{"name":"포트","slug":"포트","link":"/tags/%ED%8F%AC%ED%8A%B8/"},{"name":"블루투스","slug":"블루투스","link":"/tags/%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/"},{"name":"Bluetooth","slug":"Bluetooth","link":"/tags/Bluetooth/"},{"name":"통신","slug":"통신","link":"/tags/%ED%86%B5%EC%8B%A0/"},{"name":"저전력","slug":"저전력","link":"/tags/%EC%A0%80%EC%A0%84%EB%A0%A5/"},{"name":"소켓","slug":"소켓","link":"/tags/%EC%86%8C%EC%BC%93/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"}],"categories":[{"name":"SpringBoot-JPA","slug":"SpringBoot-JPA","link":"/categories/SpringBoot-JPA/"},{"name":"(Tutorial) Deploy-SpringBoot-Netty","slug":"Tutorial-Deploy-SpringBoot-Netty","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/"},{"name":"Simulator","slug":"Simulator","link":"/categories/Simulator/"},{"name":"java8(JDK1.8)","slug":"java8-JDK1-8","link":"/categories/java8-JDK1-8/"},{"name":"3 - Entity","slug":"SpringBoot-JPA/3-Entity","link":"/categories/SpringBoot-JPA/3-Entity/"},{"name":"Reactor-Pattern","slug":"Reactor-Pattern","link":"/categories/Reactor-Pattern/"},{"name":"6","slug":"Tutorial-Deploy-SpringBoot-Netty/6","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/6/"},{"name":"5 - SSL적용","slug":"Tutorial-Deploy-SpringBoot-Netty/5-SSL적용","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/5-SSL%EC%A0%81%EC%9A%A9/"},{"name":"2","slug":"Tutorial-Deploy-SpringBoot-Netty/2","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/2/"},{"name":"3","slug":"Tutorial-Deploy-SpringBoot-Netty/3","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/3/"},{"name":"Carla-Simulator","slug":"Simulator/Carla-Simulator","link":"/categories/Simulator/Carla-Simulator/"},{"name":"1 - Hibernate","slug":"SpringBoot-JPA/1-Hibernate","link":"/categories/SpringBoot-JPA/1-Hibernate/"},{"name":"1 - 기본배포","slug":"Tutorial-Deploy-SpringBoot-Netty/1-기본배포","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/1-%EA%B8%B0%EB%B3%B8%EB%B0%B0%ED%8F%AC/"},{"name":"Lambda Expression - 1","slug":"java8-JDK1-8/Lambda-Expression-1","link":"/categories/java8-JDK1-8/Lambda-Expression-1/"},{"name":"4","slug":"Tutorial-Deploy-SpringBoot-Netty/4","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/4/"},{"name":"2 - SpringData-JPA","slug":"SpringBoot-JPA/2-SpringData-JPA","link":"/categories/SpringBoot-JPA/2-SpringData-JPA/"},{"name":"포트 목록","slug":"포트-목록","link":"/categories/%ED%8F%AC%ED%8A%B8-%EB%AA%A9%EB%A1%9D/"},{"name":"안드로이드 블루투스","slug":"안드로이드-블루투스","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/"},{"name":"java.NIO","slug":"Reactor-Pattern/java-NIO","link":"/categories/Reactor-Pattern/java-NIO/"},{"name":"well-known port","slug":"포트-목록/well-known-port","link":"/categories/%ED%8F%AC%ED%8A%B8-%EB%AA%A9%EB%A1%9D/well-known-port/"},{"name":"BLE 통신","slug":"안드로이드-블루투스/BLE-통신","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/BLE-%ED%86%B5%EC%8B%A0/"},{"name":"Classic 통신","slug":"안드로이드-블루투스/Classic-통신","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/Classic-%ED%86%B5%EC%8B%A0/"}]}