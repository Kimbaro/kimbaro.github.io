{"pages":[],"posts":[{"title":"Carla simulator","text":"","link":"/2020/02/17/Carla-simulator/"},{"title":"JPA Entity Annotation 정리","text":"본 내용은 자바 ORM 표준 JPA 프로그래임 (김영환 지음)을 참고하였음. Requirements Springboot 2.2.4.RELEASE Gradle 6.0.1 Dependencies(implementation) org.springframework.boot:spring-boot-starter-data-jpa org.springframework.boot:spring-boot-starter-web org.springframework.boot:spring-boot-starter-data-jdbc Dependencies(compileOnly) org.projectlombok:lombok Dependencies(runtimeOnly) com.oracle.ojdbc:ojdbc8 Dependencies(testCompile) junit:junit:4.12 DBMS Oracle Database 11g Standard Edition One(se1) Entity 맵핑에 있어 XML을 이용한 외부에서의 설정 방식과 Annotation을 이용한 내부에서의 설정 방식이 있다.이중 사용이 간편하고 상대방이 보기에도 코드가 직관적인 장점을 지닌 Annotation방식을 이용하며,다양한 상황에 따른 테이블의 제약조건을 가정하여 매핑 작업에 활용된 Annotation을 정리한다. 목차 객체와 테이블 매핑 @Entity @Table 기본 키 매핑 직접할당 자동생성(Sequence전략) 필드와 컬럼 매핑 @Column 연관관계 매핑 @ManyToOne @JoinColumn 본문1. 객체와 테이블 매핑annotation entityJPA를 사용하는 경우 DB 테이블과 매핑될 클래스는 @Entity가 붙는다. 이는 JPA 프레임워크에서 관리하며 다음과 같은 주의 사항이 있다. 기본 생성자는 필수(public 또는 protected) final 클래스 같은 상수와 추상객체인 enum,interface,inner 클래스에는 사용 불가. 맵핑할 객체에 final은 사용할 수 없다. 기본 생성자가 없는 경우 아래와 같이 ‘JpaSystemException’ 에러가 발생하며 ‘No default constructor for entity’ 의 메시지로사용자에게 기본 생성자가 선언되지 않았음을 알리고 있다. annotation tableEntity 오브젝트와 매핑할 DB의 테이블 명을 지정한다. 각 속성은 아래와 같다. uniqueConstraints DDL생성 시 Entity 오브젝트에서 복수개의 unique 제약조건을 지정하기 위해 사용된다. 각각의 uniqueConstraints의 지정된 값은 @Column의 name속성 값을 따른다. unique column은 각 속성, name과 columnNames로 구성되며 name의 경우 DDL을 DBMS에 전달하여 해당 내용으로 unique index를 생성한다. indexes RDBMS의 대용량 데이터를 관리하는 경우 검색 속도를 높히기 위한 작업이다. 생성된 Table의 Column에 색인을 지정하여 따로 색인정보가 담긴 파일을 생성하고 select 요청 시 해당 Table을 전체 스캔하는 것이 아닌 색인화 된 Index 파일을 검색한다. Oracle의 경우 색인 알고리즘인 B-tree(binary search tree)를 적용하고 있다. Entity Mapping에서 사용된 @Index의 속성값 name은 색인 검색을 위한 파일 명, columnList는 색인을 위한 Column name이다. catalog 맵핑할 DB catalog를 매핑한다. schema schema를 매핑한다. name 맵핑할 DB table 이름을 지정한다.1@Table(name = &quot;MY_FAVOLITE&quot;) 2. 기본 키 매핑직접할당Database의 Row Column 값을 구분을 위한 기본키(Primary Key)를 직접 할당한다. 123@Id@Column(name = &quot;ID&quot;)private long id; 자동생성대리키(Alternate key)를 사용한 방식. JPA에서의 기본키 생성 전략 은 다음과 같다. IDENTITY 전락 : 기본키 생성을 데이터베이스에 위임하여 관리한다 (MySQL, PostgreSQL 등) TABLE 전략 : 키 생성을 위한 테이블을 하나 만들고 이름과 값으로 컬럼을 만들어 데이터베이스 Sequence를 흉내낸다. SEQUENCE 전략 : 데이터베이스의 Sequence는 Unique 값을 순서대로 저장하는 하나의 오브젝트이다. JPA에선 Entity에 @SequenceGenerator를 선언하여 관리한다. *본 절에선 Oracle을 사용한 Sequence 전략을 다뤘음. annotation SequenceGenerator3. 필드와 컬럼 매핑annotation column4. 연관관계 매핑annotation many to oneannotation join column","link":"/2020/02/17/JPA-Entity/"},{"title":"java.NIO 패키지를 활용한 Reactor-Pattern 채팅","text":"Intro Old I/O의 문제점 과 이를 개선한 New I/O프로젝트파일 : https://github.com/Kimbaro/SocketChatApp.git Environment IntelliJ IDEA IntelliJ Plugin, UI Designer(Java Swing GUI) Java (openjdk 1.8.0_232) Apache Commons Codec 1.14 Main Function Old I/O pattern의 ServerSocket을 New I/O Reactor Pattern의 ServerSocketChannel로 변경 적용하여 기존 동기화 방식의 소켓채팅을 비동기 방식의 소켓 채팅으로 변경. 하나의 채팅프로그램에서 동적으로 변경 가능한 BroadCast통신과 UniCast통신 적용. 클라이언트 임의의 비밀키를 생성하고 데이터 암호화를 적용하고 해당 데이터를 클라이언트와 서버와의 공개키를 활용한 이중암호화를 적용한 대칭키암호 AES256 알고리즘 적용한 암호화 통신 적용. 네트워크 프로그래밍의 기존 소켓 통신은 아래와 같은 패턴을 따른다. 클라이언트가 Connect()를 수립한 경우 서버의 accept()에 의해 Client Socket이 반환된다 이를 동기중인 클라이언트소켓이라 생각해도 무방하다. 해당 소켓을 활용해 I/O를 로직의 반복루프를 통해 새로 들어온 데이터가 있는지 체크 한다.이 경우 데이터를 체크하고 보내고 받기 위한 작업은 SubThread에서 처리한다. 위 그림과 같이 기존의 과정의 경우 문제가 발생할 수 있다.클라이언트(접속자)가 많아 질수록 그만큼 스레드는 클라이언트 접속자에 맞춰 계속해서 늘려가야 한다.이 경우 메모리 구조상 Stack영역과 Heap영역의 무분별한 할당이 진행될 것이다. 아래 그림 처럼, 새로운 클라이언트의 접속(붉은색)이 발생(Accept)할 때 MainThread는 SubThread(주황색)를 생성한다. N명의 접속이 발생할 경우접속한 N명의 수에따라 SubThread를 계속해서 생성하며 과도한 접속이 발생할 경우 그에 따른 부담이 발생할 수 있다. 이런 무분별한 메모리 영역 낭비를 보완하여 NIO란 방식이 고안되었다.NIO를 Non-blocking Input/Output 또는 New Input/Output이라 부르고 있다.Java에선 JDK1.4부터 이를 지원하기 시작하였으며, Client가 연결을 시도할 경우 해당 클라이언트를 구분하기 위한 채널(SocketChannel) 객체를 생성한다. 이후 Selector객체는 각 채널(SocketChannel)의 소켓 연결 이벤트(Connect, Accept, Read, Write)에 반응하여 이벤트가 발생한 채널의 키를 반환한다. 상황에 반응(Reactor)하여 작업을 시도하는데 여기서 키는 서버와 연결된 Client의 대상을 구분하기 위한 식별자이며네트워크정보를 포함하고 있다. 아래의 이미지와 같다. 이러한 과정을 Reactor-Pattern이라 하며 우리말로 반응형 패턴이라 볼 수 있다.이제 해당 패턴을 적용한 채팅프로그램을 리뷰한다.java.nio 패키지에서 활용되는 주요 클래스의 역할을 알아본다. SocketChannels : 소켓을 통해 non-blocking read를 할 수 있도록 지원하는 connection. Selector : Selector는 어느 channel set 이 IO event 를 가지고 있는지를 알려준다. Selector.select() 는 I/O 이벤트가 발생한 채널 키를 return한다.return channel이 없다면 계속 기다리게(block) 된다. 2번의 과정에 의해 block된 Selector를 강제로 동작 시켜주는 것이 Selector.wakeup()이다. Selector.selectedKeys()는 이벤트가 발생한 키, 즉 SelectionKey 를 return 해 준다. Reactor는 이 SelectionKey를 보고 어떤 handler로 넘겨줄 지를 결정한다. SelectionKey : Selector와 Channel간의 관계를 표현해주는 객체이다. Selector가 제공한 SelectionKey를 이용해 Reactor는 채널에서 발생하는 I/O 이벤트로 수행할 작업을 선택할 수 있다. ServerSocketChannel에 selector를 등록하면 key를 준다. 이 key가 SelectionKey 이다. 리뷰Part 1. NIO를 위한 객체 생성 (NiochatServer.class) 13 : Runnable을 implements하고 있음을 유의한다.17 : Server의 SocketChannel을 생성한다. 클라이언트의 accept를 수립하는 역할을 한다.18 : 생성된 모든 채널 정보와 각 채널의 이벤트 정보를 담고 있는 역할을 한다.28 - 29 : Selector와 SecverSocketChannel 객체는 open() 메서드로 초기화 한다.31 - 33 : ServerSocketChannel의 메서드는 다음과 같다. socket() : ServerSocket을 반환한다. 이후 네트워크에 IP,PORT를 바인딩한다. configureBlocking() : true인 경우 Blocking, false인 경우 Non-Blocking register() : Selector(선택자)에 서버의 채널정보(Key)를 등록하고 OP_ACCEPT 이벤트를 발생한다. Part 2. 이벤트 반응(Reactor) (NiochatServer.class) 45 : 저장된 Keys 중 이벤트(Connect, Accept, Read, Write)가 감지될 때 까지 Block상태로 대기한다. 이벤트가 발생할 경우 이에 반응해 해당하는 클라이언트(Key)를 SelectionKey객체로 반환한다.51 : Selector와 SelectionKey를 인자로 받아 이벤트를 처리 작업을 진행한다. (EventManager내부로직은 아래서 다시 설명.)53 : 인자로 받은 SelectionKey중 OP_ACCEPT와 같은 이벤트인 경우 해당 클라이언트(Key)를 accept 하기 위한 메서드 이다.55 : 인자로 받은 SelectionKey중 OP_ACCEPT를 제외한 다른 이벤트인 경우 subThread를 생성해 read/write 또는 disConnect여부를 처리 후 종료한다. 참고 - SelectionKey에서 제공 중인 이벤트 상수는 다음과 같다. Part 3. 이벤트 처리 (EventManager.class Thread) 19 : EventManager객체는 Runnable을 implement 하고 있음을 유의한다.24 - 26 : Selector.select()에 의해 반응한 이벤트정보가 담긴 SelectionKey를 인자로 받는다.33 - 50 : 인자로 받은 SelectionKey에 담긴 이벤트가 무엇인지 key.interestOps() 함수로 반환 받으며, switch-case를 통해 어떤 이벤트인지 판단한다. 본 채팅 프로그램에서 구현한 이벤트는 송/수신 부분이다. 서버는 해당하는 키채널에게 수신받을 준비가 되었음. READ =&gt; SelectionKey.OP_READ서버는 해당하는 키채널에게 송신할 준비가 되었음. WRITE =&gt; SelectionKey.OP_WRITESelector가 처리할 수 있는 이벤트 요소가 무엇이 있는지는 이미지(SelectionKey에서 제공 중인 이벤트 상수)를 참고. Part 4. (Function 1) OP_ACCEPT 이벤트 기능 구현, EventManager.handleAccept(Selection key) 54 : (그림6 52번 라인 참고) Selector가 OP_ACCEPT이벤트를 감지할 경우 대상 키를 반환받아 SelectionKey.accept()로 서버에 접속을 수용한다. 이 경우 Selector내부에 해당 클라이언트의 네트워크 정보가 담긴 Key 채널을 저장한다.58 : 해당 클라이언트의 이벤트처리 동작을 non-blocking으로 수행한다. true인 경우 blocking으로 수행한다.59 : Selector에 최종적으로 클라이언트 채널을 등록하며 해당 채널의 이벤트 상태를 OP_READ로 대기한다. =&gt; OP_READ로 지정하여 클라이언트가 connect하면서 보낸 메시지를 읽는다. Part 5. (Function 2) OP_READ 이벤트 기능 구현, EventManager.handleRead(Selection key) 70 : 이벤트 변경감지된 클라이언트키(Selection key)를 인자로 key.channel() 메서드를 통해 해당 키의 네트워크정보가 담긴 채널 객체 SocketChannel을 생성한다.74 : 클라이언트가 보낸 데이터는 바이트버퍼로 이뤄져 있으며, SocketChannel.read(ByteBuffer dst)에서 매개변수로 지정된 ByteBuffer 값 만큼 단위로 끊어 읽는다. 읽어낸 값은 StringBuilder에 의해 대용량문자데이터를 입력받아 초기화한다.84 : 클라이언트가 종료하여 클라이언트의 Write Thread가 0byte를 보낸다면 서버는 데이터를 “exit:”로 초기화하여 EventManager.strAPI() 함수에서 처리한다. Part 6. (Function 3) OP_WRITE 이벤트 기능 구현, EventManager.handleWrite(Selection key) 97 : 해당 클라이언트 Key에 부착된 ClientOption을 반환받는다. 클라이언트의 전반적인 기능과 정보가 담겨있고 이벤트 진행여부를 스위치 하기위한 정보가 담겨있다.99 : ClientOption에 1:1 대화를 위한 상대방 클라이언트 Key가 저장되어 있는지 파악한다. 해당 if구문으로 해당 클라이언트가 브로드캐스트상태인지 유니캐스트상태인지 구분하고 있다.100 : 신규로 채팅방에 접속한 클라이언트인지 여부를 구분한다. 신규 유저인 경우 서버에서 채팅방 참여중인 클라이언트 모두에게 join: 기능의 메시지를 뿌려 소개한다.105 - 116 : 현재 채팅방에 접속중인 클라이언트 닉네임을 ‘,’콤마 단위로 구분해 문자열로 저장한다.118 - 119 : 서버가 클라이언트에게 보내는 내용은 다음과 같다.join:{클라이언트닉네임}:{ClientNickname1,ClientNickname2,ClientNickname3, . . .}이후 해당 내용을 브로드캐스팅한다.121 : 만일 신규접속자가 아닌 경우 클라이언트 메시지를 read하여 브로드캐스팅한다.125 : 99번 라인에서 1:1대화를 위한 상대방 클라이언트 Key가 Null이 아니라면 클라이언트와 1:1 대화를 요구하는 파트너의 키를 인자로 유니캐스트를 진행한다.134 : Selector의 이벤트 상태를 OP_READ로 변경하여 클라이언트로부터 데이터를 받을 준비를 한다.135 : Selector.select()에서 블로킹 상태를 깨워 로직을 진행한다. Part 7. (Function 4) 브로드캐스팅 동작 구현, EventManager.broadcast(String msg) 138 : Selector.keys()를 통해 등록된 채널(Key)를 반환한다.139 : 해당 채널이 유효한지 판단 하는 key.isValid()와 네트워크 정보가 담긴 channel()를 반환해 유효하며 네트워크 정보가 담겨 있는지 여부를 파악 후 SocketChannel의 인스턴스를 반환한다.142 : SocketChannel.write()는 서버가 해당 소켓 채널에 메시지를 보낸다. Part 8. (Function 5) 유니캐스팅 동작 구현, EventManager.unicast(String msg, SelectionKey partnerKey) 155 : unicast()의 두 번째 매개변수인 partnerKey는 클라이언트간 1:1 대화를 위한 상대방 키 정보이다.158 - 163 : 두 채널 정보가 담긴 whisperUsers 배열을 for-each 루틴으로 두 채널에 메시지를 보내는 과정이다. Part 9. (Function 6) 서버와 클라이언트간 약속된 명령어 EventManager.strAPI(String data, clientKey) 모든 String data값은 split‘:’ 을 통해 분류된다. APIs 형식 기능 join: join:{user nickname value} 신규 참여자 임을 서버에 알리며 닉네임을 포함한다. message: message:{message} 채팅메시지를 포함한다. exit: exit: 클라이언트 채팅 종료 whisper: whisper:{partner nickname value}:{message} 1:1 채팅을 위해 파트너 닉네임과 메시지를 포함한다. envelope: envelope:{private key@data} AES256 대칭키 암호화 데이터를 전송한다. unknown Type - 아무런 타입도 없다면 message: 로 처리한다. Part 9.1 (API type = join) join: 의 이벤트 처리 클라이언트는 connect 요청 시 join: 메시지를 함께 전송한다.해당 클라이언트의 채널은 SelectionKey.attach()에 독점자원인 ClientOption을 초기화하여 해당 클라이언트의 다양한 상황에 따른 스위치 역할을 한다. Part 9.2 (API type = message) message: 의 이벤트 처리 메시지를 split하여 해당 클라이언트의 attacment객체의 ClientOption에 문자열을 할당한다.이후 SelectionKey.interestOps()로 현재 SelectionKey의 이벤트처리 유형을 OP_WRITE로 변경하고 Selector.wakeup()로 block 상태인 Selector.select() 스레드를 동작 시킨다. Part 9.3 (API type = exit) exit: 의 이벤트 처리 exit인 경우 해당 채널을 닫고 =&gt; SelectionKey.channel().close()해당 내용을 각 클라이언트에게 브로드캐스팅한다. Part 9.4 (API type = envelope) envelope: 의 이벤트 처리 본 어플리케이션에서 암호화는 두단계로 이뤄진다.공유키(Public Key)는 클라이언트와 서버만 알고 있는 암호키 이다.클라이언트는 비밀키(Private Key)를 공유키로 자신을 암호화한다.비밀키는 클라이언트가 작성한 평문(Plain Message)를 암호화한다. 이후 문자를 조합해 서버로 보낸다. 형식은 다음과 같이.envelope:{공유키로 암호화된 비밀키}@{비밀키로 암호화된 암호문} 의 형식으로 이뤄져 있다.위 이미지는 클라이언트에서 처리하는 암호화 과정이다. 동작1. 메시지 암호화 및 송/수신 팝업에서 확인 클릭 시 암호화된 메시지로 변환 채팅 내용을 보면 ‘@’가 확인됨. 해당 문자 기준 좌측은 암호화된 키, 우측은 암호화된 문자로 구분함. 클라이언트에서의 암호화 전송 시 로그 서버에서의 암호화 수신 시 로그. 복호화 정상 확인. 2. 귓속말(1:1) 채팅 테스트 test123이 test3과 test2각각의 사용자에게 메시지를 보냈다.결과, 보낸 대상 외 다른 사용자는 해당 메시지를 확인하지 못하게 된다. Report비동기 방식의 시스템 전망간단히 java를 활용해 비동기적인 채팅앱을 만들어 보았다. 느낀점은 다음과 같다.기존 NIO방식은 java의 내부 패키지인 java.NIO에서 제공하고 있었으나, 이러한 비동기적 패턴을 SpringBoot Framwork의 MSA기반이 되는 Project Reactor 에서 채택하여 개별적으로 reactor.netty.tcp ,udp, http와 같은 패키지를 제공함에 따라 비동기방식의 Reactor-Pattern의 채팅을 구현할 수 있게 되었다.중요한 포인트는 Project-Reactor는 SpringBoot MSA환경 최적화된 프레임워크이다. 이에 단순히 java project를 통한 채팅앱이 아닌 reactor.netty 패키지를 활용하기에 적합한 SpringBoot위에서 채팅 서버를 적용할수 있을 뿐더러TCP 외에도 HTTP, UDP 같은 통신프로토콜을 적용한 채팅기능을 구현해 볼 수 있지 않을까? 기존 Back-End의 MVC 패턴구조에서 마이크로서비스아키텍처가 유행함에 따라 Reactor-Netty 서버는 꼭 알아야할 부분이며, 레퍼런스와 워크숍을 제공하고 있어 스타트가이드라인으로 많은 정보를 쉽게 얻을 수 있다. https://projectreactor.io/docs/netty/release/reference/index.html#about-doc https://violetagg.github.io/reactor-netty-workshop/#_tcp_server_and_client reactor-pattern을 이해하기위해 java.NIO를 참조해 간단한 앱을 제작하며 시스템구조와 동작과정을 이해할 수 있게되었다.언젠가, 귀차니즘을 물리치는 날이 온다면,java.NIO가 아닌 reactor.netty 패키지를 활용한 NIO 통신을 다뤄보고 이를 SpringBoot에 적용하여 HTTP와 TCP, UDP 다음의 3가지 통신을 유연하게 풀어내보고 싶다. 자료를 정리하다보니, 마침 SpringBoot-netty 에서의 채팅을 구현한 우아한리뷰가 있었다. 올려놓고 나중에 봐야지, https://woowabros.github.io/experience/2020/06/19/chat-app.html","link":"/2020/11/24/NIO-Chat/"},{"title":"JPA-Hibernate","text":"본문JPA를 요리하자. ORM(Object Relational Mapping)은 객체관계매핑으로 관계형데이터베이스(RDBMS)와 1:1 매핑관계를 이룬 방식이다.기존 JDBC의 비지니스 모델링 객체의 Entity는 DTO개념 그대로 DB와 Server간 데이터 교환만을 위해서 존재했다면,ORM 방식을 통한 Entity는 관계형데이터베이스의 Row 단위로 1:1 매핑을 이뤄 해당 Entity 자원만 가지고 있다면 쉽게 CRUD가 가능하다.신뢰할 수 있는 데이터 여부에 따라 영속성, 비영속성 관계로 부른다. ORM 방식 중 JAVA에서 차용한 기술명세가 JPA이다.해당 ORM 프레임워크중 대표적인 것은 다음과 같다. JPA(Java Persistence Api) Hibernate EclipseLink DataNucleus SpringBoot는 Hibernate를 기본 제공자로 구성하기 때문에 이를 기반으로 JPA를 작성하도록 만든 Repository가 있다. ‘org.springframework.boot:spring-boot-starter-data-jpa’ 해당 주소를 gradle에 적용만 해준다면 알아서 Initialize해준다. 우리는 data-jpa를 활용해 개발에만 집중할 수 있어 친절하다. Hibernate를 간단하게 이용해보자.,#참고하면 도움 될 주소, (이미지출처)Hibernate Document Link 위 주소의 userguide에서 가져온 관계도이다. Hibernate는 다음의 객체를 제공한다. 클래스 내용 SessionFactory (org.hibernate.SessionFactory) SessionFactory는 말 그대로 Session생성하기 위한 공장이다. 사용자 요청에 따라 수십 수만개의 Session을 생성한다. 어플리케이션 전체 접근자는 이 하나의 객체를 공유한다. Session (org.hibernate.Session) 우리는 Session의 구현체인 EntityManager를 다룰것이다. 이는 단일 스레드로 동작하며 JDBC를 내부에 포함하고 있어 DB와 Connection 역할을 담당한다. Transaction (org.hibernate.Transaction) EntityTransaction은 Connection된 이후 트랜잭션 영역을 관리한다. 0. Requirements본 포스팅은 다음과 같은 환경임. Build Version Springboot 2.2.5.RELEASE Gradle 6.2.2 Dependencies(implementation) org.springframework.boot:spring-boot-starter-data-jpa org.springframework.boot:spring-boot-starter-web org.springframework.boot:spring-boot-starter-data-jdbc Dependencies(compileOnly) org.projectlombok:lombok Dependencies(runtimeOnly) com.oracle.ojdbc:ojdbc8 Dependencies(testCompile) junit:junit:4.12 DBMS Oracle Database 11g Standard Edition One(se1) IDE Build Tool IntelliJ IDEA 1. datasource 작성 및 DDL설정Springboot 2.0 이상부턴 DBCP를 사용하지 않는다. HikariCP를 default로 사용하며 기존 datasource 설정은 그대로 사용하되 나머지 Pool에 대한 설정은HikariCP가 담당한다.* DBCP2와 HikariCP 성능분석 보러가기 path : resources/application.yml12345678910111213141516171819202122spring: datasource: driver-class-name: oracle.jdbc.OracleDriver url: jdbc:oracle:thin:@&lt;URL&gt;:&lt;PASSWORD&gt;/&lt;USERNAME&gt; username: &lt;USERNAME&gt; password: &lt;PASSWORD&gt; hikari: connection-timeout: 30000 maximum-pool-size: 5 minimum-idle: 5 validation-timeout: 5000 idle-timeout: 600000 max-lifetime: 1800000 leak-detection-threshold: 0 jpa: hibernate: ddl-auto: update show-sql: true generate-ddl: true * hikariCP의 각 속성정보는 다음의 포스팅을 참고하였음.* DDL 설정관련 다음 포스팅 참고하였음. jpa.hibernate.ddl-auto none: 아무것도 실행하지 않는다 (대부분의 DB에서 기본값이다) create-drop: SessionFactory가 시작될 때 drop및 생성을 실행하고, SessionFactory가 종료될 때 drop을 실행한다 (in-memory DB의 경우 기본값이다) create: SessionFactory가 시작될 때 데이터베이스 drop을 실행하고 생성된 DDL을 실행한다. update: 변경된 스키마를 적용한다. validate: 변경된 스키마가 있다면 변경점을 출력하고 애플리케이션을 종료한다. jpa.hibernate.show-sql true, false : DB에 전달한 쿼리를 로그에 띄울지 여부를 결정한다. jpa.hibernate.generate-ddl true, false : jpa.hibernate.dll-auto 옵션을 사용할 것인지 여부를 결정한다. JPA를 활용한다면 DB에 접근해 일일이 DDL을 보내지 않고도 쉽게 생성이 가능하다. 단, ddl-auto의 value값의 내용을 보면 알 수 있듯 잘못하다간 기존 적용하여 사용중인DB를 날리는 수 있으니 다양한 테스트케이스를 확인할때만 해당 기능을 활용하는 것이 좋을 것이다. 2. 자동기본키 매핑JPA 기본키 매핑 JPA Primary Key Automatic Primary Key Application Set Primary Key Composite Primary Key Embedded Primary Key Obtaining the Primary Key 해당 포스트는 @GeneratedValue 를 적용해 Oracle의 자동증가 시퀸스를 활용한 Automatic Primary Key 매핑을 다뤄본다. Domain 객체 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.kimbaro.test.demo.domain;import lombok.Builder;import lombok.Data;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.UpdateTimestamp;import javax.persistence.*;import javax.validation.constraints.NotNull;import java.io.Serializable;import java.sql.Timestamp;@Entity@Data@Table( name = \"USER_INFO_DB\", uniqueConstraints = {@UniqueConstraint( name = \"USER_INFO_UNIQ\", columnNames = {\"NICKNAME\"})}, indexes = {@Index( name = \"USER_INFO_IDX\", columnList = \"NICKNAME,NAME\")})@SequenceGenerator( name = \"USER_INFO_SEQ\", sequenceName = \"USER_INFO_SEQ_1\", allocationSize = 2, initialValue = 1)public class USER_INFO implements Serializable { @Id @GeneratedValue( strategy = GenerationType.SEQUENCE, generator = \"USER_INFO_SEQ\") private long ID; @Column(name = \"NICKNAME\") @NotNull private String NICKNAME; @Column(name = \"NAME\") @NotNull private String NAME; @Column(name = \"GENDER\") @NotNull private char GENDER; @Column(name = \"AGE\") @NotNull private int AGE; @Column(name = \"CREATE_DATE\") @CreationTimestamp private Timestamp CREATE_DATE; @Column(name = \"LOGIN_DATE\") @UpdateTimestamp private Timestamp LOGIN_DATE; @Builder public USER_INFO(String NICKNAME, String NAME, char GENDER, int AGE) { this.NICKNAME = NICKNAME; this.NAME = NAME; this.GENDER = GENDER; this.AGE = AGE; } public USER_INFO() { }} @SequenceGenerator의 설정에 의해 “MY_FAVOLITE_SEQ_1” 이란 시퀸스가 생성될 것이다.@CreationTimestamp는 해당 Entity를 insert하는 경우 현재 시간을 반영하며, @UpdateTimestamp는 해당 id의 Entity가 DB와 매핑될때마다 그 시간대를 update한다.* 각 Annotation의 상세한 내용은 해당 링크를 참고하도록 한다. 이후 빌드 후 DB에 연결하여 내용을 보면 해당 테이블과 설정된 키 정보가 생성되어 있다. ddl-auto의 값이 update이고 서버를 빌드할때마다 show-sql:true로 인해 db에 어떤 쿼리를 전달하는지 로그에 작성되어 있을 것이다.해당 설정 정보가 DB서버와 다르다면 Entity에 적용된 설정으로 DB서버에 반영되므로 이에 주의하여 상황에 따라 ddl-auto의 값을 변경해줘야 한다. 3. Persistence Context 설계자바 ORM표준 JPA프로그래밍 김영환 (저자) 를 참고하면 다음과 같이 설명하고 있다.”Persistence Context”는 “영속성 컨텍스트”로 엔티티를 영구 저장하는 환경이다.JPA에서 엔티티의 생명주기에 따라 다음과 같이 4가지 상태가 존재하는데 비영속 영속 준영속 삭제 각각의 상태에 따라 엔티티가 어떻게 이루는지 테스트 케이스를 작성하며 알아본다. 4. Test case 작성Transaction처음 언급했던 Hibernate가 제공하는 EntityManagerFactory, EntityManager, EntityTransaction과 서비스로직을 작성해 hibernate_save()실행해본다. 12345678910111213141516171819202122232425262728@Testpublic void hibernate_save() { EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); try { transaction.begin(); //트랜잭션 시작 //서비스 로직 동작 영역 save(em); transaction.commit(); //트랜잭션 커밋 } catch (Exception e) { transaction.rollback(); //트랜잭션 롤백 e.printStackTrace(); }}@Testpublic void save(EntityManager em) throws Exception{ USER_INFO user_info = new USER_INFO().builder() .NICKNAME(\"kimbaro\") .NAME(\"HongGilDong\") .AGE(11).GENDER('남') .build(); em.persist(user_info);} table을 조회하니 Entity 객체에 대입한 값과 동일하게 매핑이 되어 있다. 비영속상태23~28 Line을 보면 USER_INFO 라는 Entity객체가 초기화 되는 과정이 담겨있는데 해당 구간에서 USER_INFO에 대입된 값은 식별자(ID값)가 없는 상태이다. 영속상태이후 em.persist() 메서드를 불러오는데 이 경우 USER_INFO를 DB에 보내기 위한 식별자(ID)를 할당한 상태이다. 해당 객체 정보는 아직 DB에 저장된 상태는 아니지만EntityManager가 관리하는 1차 캐시에 올라간 상태이다. 정상적으로 영속상태 인지 여부는 EntityManager.contains를 통해 확인해 볼 수 있다. 준영속상태에서 영속상태로 병합persist()메서드를 통한 EntityManager 의 캐시에 객체가 담긴 경우 식별자 값이 해당 객체에 할당된다. 이후 EntityManager의 캐시에서분리된다면 이를 준영속 상태라 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.kimbaro.test.demo;import com.kimbaro.test.demo.domain.USER_INFO;import org.junit.Assert;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.persistence.*;import javax.transaction.Transactional;@SpringBootTestclass DemoApplicationTests { // 서버 빌드 시 초기화된 팩토리 객체를 불러온다. // persistence unit의 name을 지정 하지 않은경우 default // 팩토리는 서버를 빌드하며 초기화를 진행한다. @PersistenceUnit private EntityManagerFactory emf; @Test @Transactional public void hibernate_save() { EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); USER_INFO user_info = new USER_INFO().builder() .NICKNAME(\"kimbaro_5\") .NAME(\"HongGilDong\") .AGE(11).GENDER('남') .build(); try { transaction.begin(); //트랜잭션 시작 /* 서비스 로직 동작 영역 */ save(user_info, em); transaction.commit(); //트랜잭션 커밋 em.close(); // EntityManager 에 담긴 캐시를 모두 제거 } catch (Exception e) { transaction.rollback(); //트랜잭션 롤백 e.printStackTrace(); } em = emf.createEntityManager(); transaction = em.getTransaction(); try { transaction.begin(); /* 서비스 로직 동작 영역 */ save_merge(user_info, em); transaction.commit(); em.close(); // EntityManager 에 담긴 캐시를 모두 제거 } catch (Exception e) { transaction.rollback(); e.printStackTrace(); } } @Test public void save(USER_INFO user_info, EntityManager em) throws Exception { Assert.assertFalse(\"비영속상태, 식별자 값이 할당되어 있지 않음.\" , em.contains(user_info)); em.persist(user_info); //EntityManager에 객체 전달 Assert.assertTrue(\"영속상태, 식별가 값이 할당되어 있고 1차 캐시에 올라간 상태.\" , em.contains(user_info)); System.out.println(\"영속상태 할당받은 식별자 값 em.persist() : \" + user_info.getID()); //준영속상태(분리) //EntityManager에 저장된 캐시에 user_info 변수의 객체를 분리시킴. em.detach(user_info); Assert.assertFalse(\"준영속상태, 식별자값 할당 되어 있으나 캐시에 분리된 상태\" , em.contains(user_info)); //detached된 상태 이므로 최종적으로 DB에 값이 저장되지 않음. } @Test public void save_merge(USER_INFO user_info, EntityManager em) throws Exception { user_info.setNICKNAME(\"GamJaDa2\"); Assert.assertFalse(\"준영속상태, 식별자값 할당 되어 있으나 캐시에 분리된 상태\" , em.contains(user_info)); user_info = em.merge(user_info); //병합 System.out.println(\"영속상태, 병합 후 자동기본키 매핑으로 기본키 값이 변환됨. : \" + user_info.getID()); Assert.assertTrue(\"영속상태, 식별가 값이 할당되어 있고 1차 캐시에 올라간 상태.\" , em.contains(user_info)); }} 해당 코드를 보면 em.detach() 메서드를 통해 분리시킴을 알 수 있다. 분리된 상태에선 DB에 값이 조회되지 않는다.분리된 객체는 em.marge()를 통해 다시 병합하여 EntityManager의 캐시에 등록되고 마지막 커밋으로 DB에 insert된다.","link":"/2020/03/19/JPA-Hibernate/"},{"title":"Lambda Expression 기초","text":"목차 기존 메서드와의 문법 비교 @Functional Interface java.util.function 패키지 JDK1.8 이 추가되면서 자바의 문법구조가 크게 변화하였다.기존 JAVA의 문법에 너무 익숙해져 있는 바람에 람다식을 구지 사용해야하나 라는 의문을 가지고 있었으나 익명함수 선언 과정에서 람다식은 코드의 구조를 매우 간결하게 만들어준다.JDK1.5에 추가된 Generics을 함께 사용하여 RxJava와 Spring5.0 이후 추가된 WebFlux를 이루는 ReactiveStream은 람다와 제네릭이 매우 중요하게 다뤄지는데 조비동기 논블럭킹 방식의 앱을 구성하는데 있어 꼭 알아야할 문법 구조이다. 기존 메서드와의 문법 비교+Lambda Expression에서 Lambda는 익명함수를, Expression은 식 이다. 이는 선언하고자하는 메서드의 선언을 익명으로 객체에 주입한다. 기존의 메서드 정의1234public int compare(int num1, int num2) { return num1 &gt; num2 ? num1 : num2; } 람다식 메서드 정의1(num1, num2) -&gt; num1 &gt; num2 ? num1 : num2; 람다식은 앞서 말한 듯 익명함수를 뜻한다 메서드 선언을 비교하니 기존의 ‘반환타입’ 과 ‘메서드명’ 이 제거되고매개변수의 타입 대신에 추론 가능한 변수명을 대입한다. 아래의 경우는 자바에서 선언한 메서드를 람다식으로 표현 한 경우의 ‘예’ 이다.람다식은 Functional Interface 항목에서 구현해본다. 기존 메서드 선언과 어떻게 다른지 비교만 해보자. 1234567public void printVar(String name, int age) { System.out.println(name + \"=\" + age); } ↓↓↓↓ (name, age) -&gt; System.out.println(name + \"|\" + age); 매개변수가 하나인 경우 ‘()괄호’ 생략 가능. 1234567891011121314151617 public int sumArr(int[] arr) { int sum = 0; for (int i : arr) { sum += i; } return sum; } ↓↓↓↓ arr -&gt; { int sum = 0; for (int i : arr) { sum += i; } return sum; }; 1234567public int roll() { return (int) (Math.random() * 6); } ↓↓↓↓ () -&gt; (int) (Math.random() * 6); 기존의 메서드 구성방식과 람다식의 방식을 비교해봤다. 람다의 익명함수는 지금껏 사용해온 익명객체선언과 동일하다. 익명객체선언123456new LambdaTest() { @Override public int roll() { return (int) (Math.random() * 6); } }; 익명함수선언1() -&gt; (int) (Math.random() * 6); @Functional Interface+Functional Interface는 람다식 호출을 위해 필요하며 interface에서 구현할 람다식의 추상메서드를 선언하고 해당 interface를 구현 할 객체에 선언해주면 된다.단, 익명객체를 익명함수인 람다로 대체하기 위해선 해당 메서드의 타입과 매개변수의 개수를동일하게 선언해야만 한다.아래의 예는 함수형 interface, LambdaTest를 정의한 것이다. 1234@FunctionalInterfaceinterface LambdaTest { public abstract String test(String data,int id);} 여기서 눈에 띄는 것은 @FunctionalInterface 애노테이션인데 이는 컴파일 과정에서 LambdaTest를 올바르게 구현했는지 여부를 확인해 준다. 해당 구현체를 선언한다면 다음과 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test { public Test() { } public Test(LambdaTest lambdaTest) { } public void testMethod(LambdaTest lambdaTest) { } public static void main(String[] args) { //익명함수객체주입 LambdaTest lambdaTest = (data, id) -&gt; { String str = data; int i = id; ... }; //익명함수생성자주입 Test test = new Test((data, id) -&gt; { String str = data; int i = id; ... }); //익명함수메서드주입 Test test = new Test(); test.testMethod((data, id) -&gt; { String str = data; int i = id; ... }); //기존의익명클래스객체주입 LambdaTest lambdaTest = new LambdaTest() { public String test(String data, int id) { ... return \"\"; } }; } } 람다식을 통한 선언방식은 위와같이 익명함수를 통한 방법, 생성자 매개변수 선언을 통한 방법, 메서드의 매개변수 선언을 통한 방법다음의 3가지 방법이 있다. 이 방식은 기존의 익명클래스 선언과 다르지 않고 동일하나 람다식을 통해 코드의 구성이 좀더 직관성을 이루며 간결해진다. List객체에 Lambda를 적용한 예토비스프링 강의참고 java.util.function 패키지+","link":"/2019/05/01/Lambda-Expression%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9/"},{"title":"SpringBoot Netty 서버에 SSL 적용기 1","text":"개요본 포스팅 내용은 Google Cloud Platform의 가상머신을 통해 SpringBoot-Framework가 적용된 Web Application Server이며, 자신이 소유한 도메인이 있는 것으로 가정하고소유한 도메인을 자신의 가상컴퓨팅에 맵핑하는 과정을 정리했다. 설치가 되어 있다는 가정하에 진행한다. 준비 openSSL 라이브러리( sslforfree에서 제공해준 서명된 인증파일을 JavaKeyStore(jks)로 변환하기 위해 필요.) 도메인 ( https:// 접근을 위해 필요하다. ) 도베인적용DNS 영역 설정SpringBoot Netty서버 gradle환경에서 배포하기에서 배포한SpringBoot Netty서버에 자신의 도메인을 등록한다. 컴퓨팅환경은 Google Cloud Platform 을 통해 배포되었다.다음 예제에서 DNS와 연결할 컴퓨팅환경은 다음과 같다. 네트워크 서비스 - Cloud DNS - 영역만들기 영역이름 : 해당 DNS 영역의 이름 DNS이름 : 자신이 구매한 DNS의 이름 영역 세부정보DNS 도메인의 레코드를 설정한다. ‘레코드 모음 추가’를 선택한다. 기본적인 입력정보는 다음과 같다. A (Address Mapping records) : 도메인에 호스트의 IP주소(설정한외부IP)를 알려준다. 도메인과 IP주소의 맵핑작업이다.도메인주소 -&gt; IP주소 CNAME (Canonical Name) : 도메인을 따로 지정한 임의 도메인과 맵핑한다.임의도메인주소 -&gt; 도메인주소 NS (Name Server) : 해당 호스트의 공식 이름 서버이다. SOA (Start of Authority) : DNS서버의 설정정보가 담겨있다. DNS 네임서버 설정구매한 자신의 도메인의 네임서버를 설정한다.아래는 GoDaddy에서 구매한 도메인의 네임서버를 입력해 주는 장면이다. Google Cloud Platform의 자신의 DNS레코드에 생성된NS (Name Server)의 값을 모두 넣어준다. 앞에 ‘.’ 이 붙어있는데 이는 오류를 불러온다 지우자. DNS 레코드 맵핑 확인A (Address Mapping records)에 맵핑된 도메인정보와 IP주소가 올바른지 확인한다. 1nslookup 도메인주소 도메인 접속해보기 psGoddy를 통해 도메인을 구입했다. 해당 DNS 네임서버에 내 GCP서버의 갱신하는데 있어 약 10~15분 걸린거같다.","link":"/2019/07/29/SpringBoot-Netty-%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%E1%84%8B%E1%85%A6-SSL-%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%B5/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 2","text":"개요이전 포스팅은 SpringBoot를 로컬환경에서 배포해봤다. 이번엔 GCP의 Cloud Compute의 Ubuntu OS에서 SpringBoot를 배포를 위한 가상환경을 구성한다. 준비GCP의 가상머신 생성절차를 진행한다.컴퓨팅 - ComputeEngine - VM인스턴스 이후 아래의 이미지와 같이 본인이 원하는 서버를 구성하여 만들어줘야한다.여기서 본인은 아래 이미지와 같은 환경을 구성하였다. 이름 : 본인이 생성할 VM 인스턴스의 이름이다. 리전 : 가상머신을 실행할 서버의 위치이다. 머신구성 : 자신이 구성할 서버의 사양. 부팅디스크 : 서버를 구성할 OS. 방화벽 : 서버의 접근 방식이다. 초기 생성 시 적용할 프로토콜의 Default를 구성하는 값이다. 이제 해당 서버의 고정IP를 할당해준다.네트워킹 - VPC네트워크 - 외부 IP 주소 ‘유형=임시’ 를 ‘유형=고정’ 으로 변경해준다. ‘외부 접근허용을 위해’ 방화벽규칙을 적용한다.네트워킹 - VPC네트워크 - 방화벽 규칙 이름 : 본인이 생성할 방화벽 규칙의 이름이다. 우선순위 : 방화벽규칙에 적용될 우선순위이다. 사용환경에 따라 기본값을 달리하여 규칙을 적용할 수 있다. 대상 : 본인이 생성한 서버의 인스턴스를 대상으로 할것인지 여부를 묻는다. 소스 IP 범위 : 본인이 적용할 방화벽규칙의 IP 범위이다. 외부의 타 IP접근을 차단하거나 모두공개(0.0.0.0/0)할 수 있다. 프로토콜 및 포트 : 지정할 방화벽 규칙이다. 각 포트중 일부는 약속된 포트가 있으므로 개인의 포트를 적용할 땐 주의해야한다.다음 링크는 본인이 구성하는 기본 포트유형이다. 참고바란다.웹서버 기본 구성 포트 방화벽 규칙을 적용한 후 다음의 규칙이 적용되어 있어야한다. 8080 과 8443은 임의로 적용한 포트이며 각각 웹페이지 접근에 이용할 포트이다. ![](/images/Simple-springboot-tutorial2/5.png) GCP의 환경설정을 마무리하였다. 다음으로 외부에서 접근하기 위한 SSH키 생성 및 등록, 리눅스의 디렉토리 접근 권한을 변경해 FTP를 통해나의 VM에 파일을 전송한다.","link":"/2019/07/30/SpringBoot-Netty%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5-gradle-%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B52/"},{"title":"SpringBoot Netty 서버에 SSL 적용기 2","text":"개요이번장은 SSL (Secure Socket Layer) 인증서를 발급받고 이를 도메인이 적용된 서버에 적용하는 과정을 담았다.SSL은 Certificate Authority(CA)라 불리는 서드 파티로부터 서버와 클라이언트간에 정보교환에 있어 암호를 적용한 방식을 말한다. SSL 개념정리 무료 SSL (Secure Socket Layer) 인증서 발급받기인증서의 유효기간이 3개월로 짧은대신 무료이다.현재 DNS 주소와 연결된 서버의 도메인명을 입력해 준다. 이후 “Create Free SSL Certificate” 클릭한다.무료 SSL sslforfree“Manual Verification” -&gt; “Manually Verify Domain” “Automatic FTP Verification” - FTP 를 이용한 자동 처리 방식 “Manual Verification” - 소유권 인증 파일을 다운로드받아 직업 업로드 “Manual Verification” - DNS에 TXT 레코드로 소유권 인증 키를 추가 다음의 3가지의 발급 방식이 있는데, 본인은 “Manual Verification”을 사용하였다.도메인명을 입력하고 인증을 받기 위한 파일을 자신의 웹서버에 직접 업로드하여 인증파일을 발급받는다.인증파일은 “Manually Verify Domain” 클릭하여 진행한다. Download the following verification files by clicking on each link below 하위 목록“Download File #1” , “Download File #2”를 받은 후, Verify successful upload by visiting the following links in your browser아래의 경로를 생성하여 다운로드 파일을 업로드한다..well-known/acme-challenge/다운로드파일#1 , #2 자신의 프로젝트 아래에 resources 폴더에 위치하고있다. path등록이미지 클릭 시 확대Sample-Project에 Controller는 생성이 되어있다. 자신의 Spring-boot 프로젝트의 Controller에 해당 파일을 SSL인증 발급을 위해 경로를 설정해줘야한다. 샘플프로젝트 - https://github.com/Kimbaro/springboot-sample.git 1234567891011121314151617181920212223// import import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.core.io.Resource;import org.springframework.http.MediaType;import org.springframework.stereotype.Controller;import org.springframework.web.reactive.function.server.RouterFunction;import org.springframework.web.reactive.function.server.ServerResponse;import static org.springframework.web.reactive.function.server.RequestPredicates.GET;import static org.springframework.web.reactive.function.server.RouterFunctions.route;import static org.springframework.web.reactive.function.server.ServerResponse.ok;//class field @Bean public RouterFunction&lt;ServerResponse&gt; sslforfree1(@Value(\"classpath:/.well-known/acme-challenge/&lt;인증서파일이름&gt;\") final Resource indexHtml) { return route(GET(\"/.well-known/acme-challenge/&lt;인증서파일이름&gt;\"), request -&gt; ok().contentType(MediaType.TEXT_PLAIN).syncBody(indexHtml)); } @Bean public RouterFunction&lt;ServerResponse&gt; sslforfree2(@Value(\"classpath:/.well-known/acme-challenge/&lt;인증서파일이름&gt;\") final Resource indexHtml) { return route(GET(\"/.well-known/acme-challenge/&lt;인증서파일이름&gt;\"), request -&gt; ok().contentType(MediaType.TEXT_PLAIN).syncBody(indexHtml)); } http://URL 포트포워딩SSL 검증을 위해 사이트에서 보여준 주소는 http 형식의 80포트이다. 파일 path를 잡아줬다해도 해당 사이트에서 접근하는 경로에 유의하여80포트 접근 시 8080포트로 Redirect할 필요가 있다.(본인 환경에 따라 포트는 다를 수 있음.) 리눅스의 iptables를 활용해 규칙을 만들어준다.80 포트 -&gt; 8080포트로 Redirect 1iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 포트포워딩설정 확인 1iptables -t nat -L --line-numbers 잘못된 입력으로 인한 iptables 삭제 필요 시 1iptables -t nat -D PREROUTING &lt;해당하는리스트번호입력&gt; 규칙이 올바름에도 접속이 안될경우 자신의 GCP환경의 방화벽규칙을 확인한다. 또는 리눅스 환경에서 방화벽 접근 허용 확인 인증서 발급아래의 “Download SSL Certificate” 클릭인증서 생성이 완료되었다. “Download All SSL Certificate Files” 클릭하여 파일을 받는다. 위 이미지와 같이 3개의 파일이 있어야 한다. ca_bundle.crt certificate.crt private.key 인증서 조합이제 해당 인증서를 조합하여 하나의 아카이브로 만들어야한다. 1openssl pkcs12 -export -out 생성할파일명.pfx -inkey private.key -in certificate.crt -certfile ca_bundle.crt 생성된 pfx 형식의 파일이 있다 해당 파일이 https://URL 형식의 접근을 위한 인증서이다. 인증서 적용서버에 자신의 SNAPSHOT 파일이 위치한 경로에 pfx형식의 자신의 인증서를 저장한다. Spring-Boot의 설정파일인 Application.yml에 server의 내용을 수정한다. 12345678server: port: 8445 #SSL 사용할 포트 지정 ssl: enabled: true key-store: certificate_trco.pfx key-store-type: PKCS12 key-store-password: 123456 # pfx 생성 시 설정한 패스워드 # key-alias: trco.site # (필요시) Alias 명 지정. CSR 자동 생성시에는 CN 명 클라우드 플랫폼 방화벽 규칙 등록GCP에 사용할 SSL포트를 허용해준다. 테스트해보자. 8445 포트로 정상 실행 확인https://URL인증서내용 https://URL 포트포워딩기본적으로 도메인 접근 시 http로 접근하며 임의로 사용자가 https를 명시해야만 SSL접속을 시작하기 때문에 다음의 포트 규칙이 필요하다.해당 포스팅에서 사용된 포트는 8445임에 주의한다. 80포트 -&gt; 443포트(서버파일에서설정)1234567891011121314151617181920//사용자 환경에 따른 수정이 필요함.//가능하면 OS의 iptables 규칙 443포트 리다이렉션 포트 설정을 요함.private int http_port = 80;private int https_port = 443;@Beanpublic void startRedirectServer() { NettyReactiveWebServerFactory httpNettyReactiveWebServerFactory = new NettyReactiveWebServerFactory(http_port); httpNettyReactiveWebServerFactory.getWebServer((request, response) -&gt; { URI uri = request.getURI(); URI httpsUri; try { httpsUri = new URI(\"https\", uri.getUserInfo(), uri.getHost(), https_port, uri.getPath(), uri.getQuery(), uri.getFragment()); } catch (URISyntaxException e) { return Mono.error(e); } response.setStatusCode(HttpStatus.MOVED_PERMANENTLY); response.getHeaders().setLocation(httpsUri); return response.setComplete(); }).start();} 자신의 Spring-boot netty의 Controller에 위 코드를 명시한다.80포트 (http-default) -&gt; 443 (https-default) 443포트 -&gt; 8445포트(운영체제 iptables)12iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8445iptables -t nat -L -–line-numbers 조회해 보니 이전에 인증서 파일발급을 위해 지정했던 80-&gt;8080규칙이 존재한다. 해당 규칙은 1번 line에 위치함을 알 수 있다.(사용자마다 다르니 참고)1iptables -t nat -D PREROUTING (해당하는리스트번호입력) 해당하는 라인을 삭제 후 다시 조회해본다. iptables -t nat -L -–line-numbers 이후 서버를 실행해 접속해보자.서버에선 80포트와 8445포트를 사용하며 80포트, 즉 http로 접근한 경우 linux iptables 규칙이 아닌 서버단에서 80포트-&gt;8445포트로 Redirect한다.만일 443포트, 즉 https로 접근한 경우 linux iptables 규칙에 의해 Redirect된다. 결과https 접근 http 접근 참고 무료 SSL 보안 인증서 발급받기 (Free SSL Certificate) SSL 인증서 변환 가이드","link":"/2019/09/11/SpringBoot-Netty-%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%E1%84%8B%E1%85%A6-SSL-%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%B52/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 4","text":"개요이전글에서 파일 배포까지 완료되었다 해당 파일을 실행하여 접속해보자 배포스프링서버 배포를 위해선 java가 설치되어 있어야 한다.해당 링크를 참고하여 설치하자 리눅스우분투자바설치 저장된 배포파일로 이동하여 다음의 커맨드를 입력한다.로그를 보면 8080 포트로 현재 서버가 실행 중 임을 알리고 있다. 1java -jar 배포파일.jar 접속해보자 자신의 ‘아이피주소:8080’ 형태의 주소로 이뤄져있다. nohup 적용ssh 터미널 종료 시 java -jar로 실행된 서버또한 종료되는데 해당 프로세스의 종료를 막기위해 nohup을 활용한다. - 쉘 스크립트 생성 및 실행nohup은 쉘 스크립트 파일을 실행한다. java -jar 명령어를 쉘 스크립트 파일에 입력해야한다. 1vim start-server.sh 자신의 .jar 배포파일을 입력해주자 생성된 쉘 스크립트를 실행한다. 1nohup ./start-server.sh 만일 Permission 문제가 발생한다면 쉘스크립트와 스냅샷 파일의 권한을 변경해보자 - 프로세스 동작 확인1netstat -lntp | grep 포트번호 - ps서버단에서의 System.out.println 같은 출력문은 ‘nohup.out’에 로그가 남으니 참고.","link":"/2019/09/02/SpringBoot-Netty%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5-gradle%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B54/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 3","text":"개요이전 단계에서 GCP활용을 위해 OS이미지설치와 접근을 위한 환경설정을 마무리 하였다. 이번 단계에서 FTP접근과 배포를 위한 Spring SNAPSHOT을 가상컴퓨터환경에 배포해본다. SSH 공개키 생성운영체제 : OS X윈도우인 경우 - 윈도우 SSH키 생성 맥의 경우 ssh-keygen프로그램이 내장되어 있으므로 command에 ‘ssh-keygen’을 입력해보자 1ssh-keygen 임의의 경로인 ‘/Users/dongyounkim/Documents/Me/생성할파일명’에 생성하였다. 패스워드는 생성할때 미입력 시 이후 더이상 묻지 않는다. - 생성된 개인키와 공개키 - 커멘드 cat생성된 키 내용을 들여다 보자 1cat 생성한파일명.pub GCP 환경설정에 공개키 내용을 기입한다. - GCP SSH키메타데이터 - SSH키 - 수정/항목추가*복사한 값의 마지막을 ‘띄어쓰기’ 후 명칭을 따로 입력해줘야함을 잊지말자. FTP접속맥의 경우 ftp클라이언트가 내장되어있어 따로 프로그램을 설치할 필요가 없으나 내장된 ftp프로그램은 읽기만 가능하다.이에 본인은 FileZila를 활용하였다. FileZila 개인키 등록접속을 위해 개인키를 등록해준다.설정 - 연결 - SFTP - 키 파일 추가 접속본인의 GCP의 생성된 VM인스턴스를 참고한다.본인의 설정정보에 맞게 FTP클라이언트에 입력한다.GCP SSH키에 등록한 값의 명칭을 사용자명으로 사용한다.IANA에서 할당한 SSH 프로토콜의 포트 : 22 를 사용한다.본인의 가상컴퓨터에 접근이 완료되었다.이제 배포할때이다.배포파일은 이전 글에서 볼 수 있다. 이전글 바로가기 SSH접속 FTP를 통한 전송과정에 앞서 접근권한을 설정해준다.이를 위해선 SSH환경의 원격접속이 필요하다. 맥환경에선 내장된 접속 프로그램이 있어 쉽게 접근이 가능하다. FTP접속을 위해 생성해둔 자신의 키파일 경로로 이동해 다음의 커맨드를 입력해준다. 1ssh -i 자신개인키 사용자명@호스트주소 * FTP 접속할때의 자신의 입력정보를 참고해보자 자신의 Spring SNAPSHOT 배포파일을 저장할 디렉토리의 경로 권한을 수정해준다.본인은 다음의 경로에 파일을 관리하고자한다. 1/usr/games/ - 관리자 계정 패스워드설정1sudo passwd root - 관리자 계정 접속1su root - 경로 권한 확인12cd /usr/games/ls -la - 사용자 생성 및 그룹추가12345sudo useradd 사용자명sudo passwd 사용자명usermod -aG 그룹명 사용자명cat /etc/group ‘cd /home’ 경로로 이동해 생성한 사용자명을 확인하고 해당하는 그룹에 추가한다.‘cat /etc/group’ 추가한 자신의 계정이 정상적으로 추가되었는지 확인한다. - 그룹권한 변경자신이 배포할 경로의 권한여부를 확인 후 필요에 따라 변경해준다.여기선 /usr/games/의 경로를 다루므로 다음의 경로의 권한을 변경해준다. 123cd /usr/games/mkdir serverchmod 771 server/ 생성한 ‘server’명의 디렉터리의 접근권한 중 root그룹에 속한 계정에게 권한을 부여해준다","link":"/2019/09/02/SpringBoot-Netty%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5-gradle%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B53/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 1","text":"개요본 내용은 gradle환경의 SpringBoot-Netty서버를 GCP의 Ubuntu에 배포하고 이후 SSL을 적용한 https 환경을 구성하는 내용이다.localhost 에서 동작 가능한 Gradle 환경의 Simple SpringBoot-Netty 서버는 MSA를 기반으로 두고 있다.본 예제의 프로젝트는 다음의 깃 경로에 배포한다. https://github.com/Kimbaro/springboot-sample.git 배포용 snapshot을 생성한다.해당 프로젝트 경로의 터미널에서 다음의 커맨드를 입력한다. 12./gradlew clean./gradlew build ./gradlew clean은 빌드전에 디렉토리와 그래들 환경을 초기화한다../gradlew build는 배포를 위한 snapshot을 생성한다. build/libs 아래에 (프로젝트명)-0.0.1-SNAPSHOT.jar 의 디렉토리와 jar 파일의 생성을 확인 할 수 있다.이제 해당 경로에서다음의 커맨드를 입력한다. 이후 성공적으로 빌드가 되는지 여부를 확인해본다.로그는 다음과 같이 8080 PORT로 서버가 실행중임을 알 수 있다. 1java -jar (프로젝트명)-0.0.1-SNAPSHOT.jar 로컬환경에서 배포가 완료되었다면 다음으로 GCP의 Cloud Computing 에서 Ubuntu를 설치하고위와같이 배포하려한다.","link":"/2019/07/30/SpringBoot-gradle%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%E1%84%8B%E1%85%A6-%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5/"},{"title":"Spring Data JPA","text":"writting..","link":"/2020/03/22/SpringData-JPA/"},{"title":"Well-Known Port 정리","text":"0번 ~ 1023번 : 잘 알려진 포트(Well-Known Port)특정한 쓰임새를 위해서 IANA에서 할당한 TCP 및 UDP 포트 번호의 일부이다. 참고용 포트 TCP/UDP 설명 0 UDP 예약됨; 사용하지 않음 20 TCP FTP (파일 전송 프로토콜) - 데이터 포트 21 TCP FTP - 제어 포트 22 TCP SSH (Secure Shell) - ssh scp, sftp같은 프로토콜 및 포트 포워딩 53 TCP/UDP DNS (Domain Name System) 80 TCP/UDP HTTP (HyperText Transfer Protocol) - 웹 페이지 전송 443 TCP HTTPS - SSL 위의 HTTP (암호화 전송)","link":"/2019/08/05/Well-Known-Port-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5/"},{"title":"안드로이드 Classic 통신","text":"개요안드로이드 Classic통신은 블루투스 3.0 이하의 버전을 말하며, 블루투스 4.0 이상은 BLE통신을 뜻한다.블루투스 4.0이상의 모듈은 그 하위 버전을 포함하기도한다. 여기서 알아볼 것은 Classic한 블루투스 통신인 Socket통신이다.안드로이드는 Android Bluetooth API를 통해 블루투스 기능에 관한 엑세스 권한을 제공한다. 이 글에서 제공하는 내용은 아래와 같은 과정의 Sample Project이다 페어링된 블루투스 기기에 대한 로컬 블루투스 어댑터 쿼리 RFCOMM 채널 설정 블루투스 기기의 데이터 수신 블루투스에 관한 자세한 정보는 Document를 참고하자.https://developer.android.com/guide/topics/connectivity/bluetooth?hl=ko 해당 내용에 따른 Sample Project는 다음과 같다.https://github.com/Kimbaro/android-BluetoothClassicProtocol-Sample Pre-requisites 이름 버전 설명 Android SDK 28 - Android Build Tools v28.0.0 - 리뷰블루투스 기능 사용을 위한 권한은 다음과 같다. 123456789&lt;manifest&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; 이하내용생략 . . . 패키지 구조블루투스체크 -&gt; 기기연결 과정을 두 클래스로 나눠 진행하고 디바이스정보를 담고있는 Device클래스를 포함한다.util.BT_check , util.BT_connect , util.Device util.BT_check인스턴스를 불러오는 방법은 간단하다. 사용자가 위치한 activity , 블루투스 수신받은 데이터를 보여주기 위한 textView,상황에 따라 textView를 다른 아이템으로 바꿔 사용 할 수 있겠다. 여기서 BT_check 클래스는 그 activity와 textView를 인자로 전달받아 초기화한다. 12345678910111213141516171819public class MainActivity extends AppCompatActivity {Button button = null; TextView textView = null; Activity activity = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); activity = this; button = findViewById(R.id.bt1); textView = findViewById(R.id.tv1); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { BT_check bt_check = new BT_check(activity, textView); bt_check.checkBluetooth(); util.BT_check.checkBluetooth()블루투스 소켓 통신을 위한 메서드이며 블루투스의 전체적인 정보가 담긴 어댑터인 BluetoothAdapter를 생성하고정상적으로 블루투스가 동작하는지 통신하기전 기기를 체크한다. 123456789101112131415161718192021222324public class BT_check { private BluetoothAdapter mBluetoothAdapter = null; private Activity activity = null; private TextView textView; public void checkBluetooth() { mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (mBluetoothAdapter == null) { // 장치가 블루투스 지원하지 않는 경우 Toast.makeText(activity.getApplicationContext(), \"해당 모바일은 블루투스를 지원하지 않음\", Toast.LENGTH_SHORT).show(); } else { // 장치가 블루투스 지원하는 경우 if (!mBluetoothAdapter.isEnabled()) { // 블루투스를 지원하지만 비활성 상태인 경우 // 블루투스를 활성 상태로 바꾸기 위해 사용자 동의 요첨 Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); activity.startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); } else { // 블루투스를 지원하며 활성 상태인 경우 // 페어링된 기기 목록을 보여주고 연결할 장치를 선택. selectDevice(); } } } util.BT_check.selectDevice()페어링된 기기목록을 보여주고 연결할 장치를 선택한다. 해당 페어링 목록은 두 기기간의 연결프로세스가 성립되어 또는 성립된적이 있어서 언제든 사용할 수 있도록 디바이스가 캐싱해둔 페어링 목록을 뜻한다. 목록은 AlertDialog를 통해 띄워준다.만일 사용자가 페어링 기기를 찾아 선택했다면 블루투스디바이스와의 연결을 위한 BT_connect.class를 호출한다 해당 객체의 생성자는 다음의 인자를 받아 초기화한다.** 사용자가 위치한 액티비티, 검색된 블루투스목록, 블루투스어댑터 , 데이터가입력될 textView ** 결과적으로 BT_check.class에서 얻어온 정보를 BT_connect.class로 전달한다고 보면 된다. 12345678910111213141516171819202122232425262728293031323334353637383940Set&lt;BluetoothDevice&gt; mDevices; int mPairedDeviceCount; private void selectDevice() { //페어링되었던 기기 목록 획득 mDevices = mBluetoothAdapter.getBondedDevices(); //페어링되었던 기기 갯수 mPairedDeviceCount = mDevices.size(); //Alertdialog 생성(activity에는 context입력) AlertDialog.Builder builder = new AlertDialog.Builder(activity); //AlertDialog 제목 설정 builder.setTitle(\"등록된 디바이스\"); 이하내용생략 . . . builder.setItems(items, new DialogInterface.OnClickListener() { // 리스트 아이템 클릭 이벤트 @Override public void onClick(DialogInterface dialog, int which) { Dialog dialog_ = (Dialog) dialog; // 연결할 장치를 선택하지 않고 '취소'를 누른 경우 if (which == listItems.size() - 1) { Toast.makeText(dialog_.getContext(), \"취소\", Toast.LENGTH_SHORT).show(); } else { //취소가 아닌 디바이스를 선택한 경우 해당 영역 실행 Toast.makeText(dialog_.getContext(), \"선택 장치명 : \" + items[which].toString(), Toast.LENGTH_SHORT).show(); setDeviceName(items[which].toString()); //타겟 액티비티 ,블루투스 검색 목록 , 검증된 블루투스 정보, 받아온 값 입력대상 BT_connect bt_connect = new BT_connect(activity, getMDevices(), getMBluetoothAdapter(), textView); //본인이 선택한 블루투스이름 bt_connect.connectToSelectedDevice(getDeviceName()); } } }); util.BT_connect모든 준비가 끝났다. BT_check.class에서 생성된 데이터로 BT_connect.class가 구성되어있다. 그 외에도 소켓통신 및 이를 위한 스트림 객체등통신 및 데이터를 처리하기위한 객체가 선언되어있다. 1234567891011121314151617181920212223242526272829303132public class BT_connect { BluetoothSocket mSocket; InputStream mInputStream; OutputStream mOutputStream; Activity activity; BluetoothDevice mRemoteDevice; Set&lt;BluetoothDevice&gt; mDevices; BluetoothAdapter mBluetoothAdapter; byte[] readBuffer; //수신 데이터 int readBufferPositon; //버퍼 내 수신 문자 저장 위치 Thread mWorkerThread; byte mDelimiter = 10; private BT_connect() { } //데이터 출력 테스트용 TextView textView; Button button; public BT_connect(Activity activity, Set&lt;BluetoothDevice&gt; mDevices, BluetoothAdapter mBluetoothAdapter, TextView textView) { this.activity = activity; this.mDevices = mDevices; this.mBluetoothAdapter = mBluetoothAdapter; this.textView = textView; button = this.activity.findViewById(R.id.bt1); } 이하내용생략 . . . util.BT_connect.connectToSelectedDevice()블루투스 데이터를 실시간으로 받기위해선 스레드가 필요하다. 스트림 객체는 Handler를 통해 생성하며 BluetoothSocket.getOutputStream() , BluetoothSocket.getInputStream() 두 메서드 선언으로 스트림이 연결된다.소켓 Connect 상황에 따라 Handler에 다음의 값을 보내 상황에 따른 이벤트가 발생한다. 1인 경우 연결에 성공하여 스트림을 생성하는 단계 -1인 경우 연결에 오류가 있어 소켓을 close하는 단계 연결에 성공한 경우 데이터 수신을 처리하는 beginListenForData()를 실행한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859...위내용생략 public void connectToSelectedDevice(final String selectedDeviceName) { button.setText(\"연결중 기다려주세요\"); //handler는 thread에서 던지는 메세지를 보고 다음 동작을 수행시킨다. final Handler mHandler = new Handler() { public void handleMessage(Message msg) { if (msg.what == 1) // 연결 성공 { try { //블루투스 기기와의 소켓통신을 위한 커넥션 실행 mOutputStream = mSocket.getOutputStream(); mInputStream = mSocket.getInputStream(); // 데이터 수신 리스너 beginListenForData(); button.setText(\"연결 성공\"); } catch (IOException e) { e.printStackTrace(); } } else { //연결 실패 Toast.makeText(activity, \"연결실패! 연결상태를 확인해주세요\", Toast.LENGTH_SHORT).show(); try { mSocket.close(); button.setText(\"연결 실패\"); } catch (IOException e) { e.printStackTrace(); } } } }; //연결과정을 수행할 thread 생성 Thread thread = new Thread(new Runnable() { public void run() { //선택된 기기의 이름을 갖는 bluetooth device의 object mRemoteDevice = getDeviceFromBondedList(selectedDeviceName); UUID uuid = Device.DEVICE_UUID; try { // 소켓 생성 mSocket = mRemoteDevice.createRfcommSocketToServiceRecord(uuid); // RFCOMM 채널을 통한 연결, socket에 connect하는데 시간이 걸린다. 따라서 ui에 영향을 주지 않기 위해서는 // Thread로 연결 과정을 수행해야 한다. mSocket.connect(); mHandler.sendEmptyMessage(1); } catch (Exception e) { // 블루투스 연결 중 오류 발생 mHandler.sendEmptyMessage(-1); } } }); //연결 thread를 수행한다 thread.start(); } util.BT_connect.beginListenForData()블루투스 커넥션을 위한 해당 스레드과정에서, beginListenForData()에서 데이터를 받아 처리하기 위한 스레드가 한번더 실행된다.Queue방식으로 블루투스기기로 부터 데이터를 수신하여 handler.post에서 데이터 처리 이벤트를 진행한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//블루투스 수신 리스너 protected void beginListenForData() { final Handler handler = new Handler(); readBuffer = new byte[1024]; readBufferPositon = 0; mWorkerThread = new Thread(new Runnable() { @Override public void run() { while (!Thread.currentThread().isInterrupted()) { try { int bytesAvailable = mInputStream.available(); if (bytesAvailable &gt; 0) { //데이터가 수신된 경우 byte[] packetBytes = new byte[bytesAvailable]; mInputStream.read(packetBytes); for (int i = 0; i &lt; bytesAvailable; i++) { byte b = packetBytes[i]; if (b == mDelimiter) { byte[] encodedBytes = new byte[readBufferPositon]; System.arraycopy(readBuffer, 0, encodedBytes, 0, encodedBytes.length); final String data = new String(encodedBytes, \"US-ASCII\"); readBufferPositon = 0; handler.post(new Runnable() { public void run() { //===== 데이터 정상 수신 영역 ===== //수신된 데이터는 data변수에 의해 String형 변환되어 있음. textView.setText(data); } }); } else { readBuffer[readBufferPositon++] = b; } } } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } }); //데이터 수신 thread 시작 mWorkerThread.start(); }} 마무리해당 통신과정은 위에서 언급했듯이 Classic한 통신방법으로 기존 블루투스 3.0방식의 모듈에서 많이 활용된다.모바일에서의 동작에 있어 안드로이드 버전에 따른 여러 제약사항이 BLE에 비해 크게 변경된 사항은 없다. 그냥 돌아다니는거 써도 될 정도로.. 인턴십때문에 현장에서 스마트밴드와 호흡기측정기를 블루투스통신 하는 과정이 있었는데 덕분에 BLE와 Socket통신을 실제업무에서 적용해 볼 수 있는 기회라 참 재밌었다.","link":"/2019/09/05/%E1%84%8B%E1%85%A1%E1%86%AB%E1%84%83%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3-Socket%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB/"},{"title":"안드로이드 BLE 통신","text":"개요구글이 깃에 올려둔 Sample project 중에서 블루투스 BLE의 코드는 API21 이상의 버전과 호완성 문제를 보인다.타겟을 21로 낮추면 되겠지만 앱을 플레이스토어에 배포하기 위해선 정책이 바뀌어 API28(Android Pie)이상을 타겟으로 잡아야한다.이로인한 문제는 다음과 같고 필수적으로 변경시켜야한다. BluetoothAdapter 클래스의 stopLeScan 과 startLeScan 을 지원하지 않는다.BluetoothLeScanner 클래스를 사용한 stopScan, startScan 두 메서드를 사용해야한다. 블루투스 통신에 있어서 위치권한과 GPS를 함께 사용한다.갤럭시S8 기기에서 테스트 했었는데, 위치권한 뿐 아니라 GPS가 켜있어야 함을 알 수 있었다.https://stackoverflow.com/questions/33043582/bluetooth-low-energy-startscan-on-android-6-0-does-not-find-devices/33045489#33045489 구글이 제공한 기존의 샘플은 다음과 같다.https://github.com/googlesamples/android-BluetoothLeGatt.git 위 문제에 따른 수정본은 다음과 같다.https://github.com/Kimbaro/android-BluetoothLeGatt-API28.git Pre-requisites 이름 버전 설명 Android SDK 28 - Android Build Tools v28.0.3 - 리뷰변경점, BluetoothLeScanner 관련BluetoothAdapter클래스를 대신해 BluetoothLeScanner를 추가 12345678910111213141516private LeDeviceListAdapter mLeDeviceListAdapter; private boolean mScanning; private Handler mHandler; //추가 API21 이상부터 스캔을 위해선 다음의 클래스 사용 private BluetoothLeScanner mBLEScanner; private BluetoothAdapter mBluetoothAdapter; private static final int REQUEST_ENABLE_BT = 1; private static final int MY_PERMISSIONS_REQUEST = 2; 이하내용생략 . . . BluetoothAdapter의 스캔기능은 사용하지 않으나 Adapter 본연의 역할은 수행하고 있다.onCreate()에서 BluetoothManager의 정보를 getAdapter()를 선언하여 BluetoothAdapter에 제공하고 이 블루투스 정보를 BluetoothLeScanner 객체에 전달하고 있다. 결론으로 전체적인 흐름은 다음과 같다.*BluetoothManager =&gt; BluetoothAdapter =&gt; BluetoothLeScanner =&gt; 스캔기능 수행 * 12345678910111213141516171819202122232425262728private BluetoothLeScanner mBLEScanner;private BluetoothAdapter mBluetoothAdapter;@Override public void onCreate(Bundle savedInstanceState) { . . . 위내용생략 final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = bluetoothManager.getAdapter(); // Checks if Bluetooth is supported on the device. if (mBluetoothAdapter == null) { Toast.makeText(this, R.string.error_bluetooth_not_supported, Toast.LENGTH_SHORT).show(); finish(); return; } //추가 mBLEScanner = mBluetoothAdapter.getBluetoothLeScanner(); // Checks if Bluetooth LE Scanner is available. if (mBLEScanner == null) { Toast.makeText(this, \"Can not find BLE Scanner\", Toast.LENGTH_SHORT).show(); finish(); return; } } 변경점, BLE통신 콜백 클래스 변경BluetoothAdapter의 스캔기능이 지원되지 않으면서 그에따라 BluetoothAdapter.LeScanCallback 또한 사용하지 않는다.LeScanCallback은 interface로 단독적으로 오버라이딩하였으나 BluetoothLeScanner에 사용되는 콜백클래스인 ScanCallback은 Object를 상속받는 abstract 추상객체로 이뤄져있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 private ScanCallback mScanCallback = new ScanCallback() { @Override public void onScanResult(int callbackType, ScanResult result) { super.onScanResult(callbackType, result); processResult(result); } @Override public void onBatchScanResults(List&lt;ScanResult&gt; results) { super.onBatchScanResults(results); for (ScanResult result : results) { processResult(result); } } @Override public void onScanFailed(int errorCode) { super.onScanFailed(errorCode); } private void processResult(final ScanResult result) { runOnUiThread(new Runnable() { @Override public void run() { mLeDeviceListAdapter.addDevice(result.getDevice()); mLeDeviceListAdapter.notifyDataSetChanged(); } }); } }; // 사용하지 않음.// private BluetoothAdapter.LeScanCallback mLeScanCallback =// new BluetoothAdapter.LeScanCallback() {//// @Override// public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {// runOnUiThread(new Runnable() {// @Override// public void run() {// mLeDeviceListAdapter.addDevice(device);// mLeDeviceListAdapter.notifyDataSetChanged();// }// });// }// }; 추가, GPS의 사용블루투스 기능을 사용하기 위해선 위치권한 허용 뿐만 아니라 해당 GPS가 켜있어야한다. 그렇지 않으면 기능사용이 불가하므로 이를 방지한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//AlertDialog private void alertCheckGPS() { AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage(\"GPS를 허용해 주셔야 앱 이용이 가능합니다.\") .setCancelable(false) .setPositiveButton(\"GPS 설정\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { moveConfigGPS(); } }) .setNegativeButton(\"취소\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { dialog.cancel(); restart(); } }); AlertDialog alert = builder.create(); alert.show(); } // GPS 설정화면으로 이동 private void moveConfigGPS() { Intent gpsOptionsIntent = new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS); startActivityForResult(gpsOptionsIntent, MY_PERMISSIONS_REQUEST); } //재시작 public void restart(){ Intent i = getBaseContext().getPackageManager(). getLaunchIntentForPackage(getBaseContext().getPackageName()); i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(i); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { // User chose not to enable Bluetooth. if (requestCode == REQUEST_ENABLE_BT &amp;&amp; resultCode == Activity.RESULT_CANCELED) { finish(); return; } if (requestCode == MY_PERMISSIONS_REQUEST) { if (!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) { Toast.makeText(getApplicationContext(), \"GPS가 꺼져있습니다.\", Toast.LENGTH_LONG).show(); //앱 재실행 restart(); } } super.onActivityResult(requestCode, resultCode, data); }@Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getActionBar().setTitle(R.string.title_devices); locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); //버전체크 if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) || (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED)) { ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, MY_PERMISSIONS_REQUEST); } //GPS 설정여부 if(!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)){ alertCheckGPS(); } 이하내용생략 . . . 마무리안드로이드 API23을 타겟으로 앱 개발했다가 큰 낭패를 보았다. 막상 만들꺼 다 만들어놓고 배포하자니 API28이상만 배포 가능하다고하니..삽질을 많이 해버렸다.","link":"/2019/09/02/%E1%84%8B%E1%85%A1%E1%86%AB%E1%84%83%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3-BLE-%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB/"}],"tags":[{"name":"Carla","slug":"Carla","link":"/tags/Carla/"},{"name":"Simulator","slug":"Simulator","link":"/tags/Simulator/"},{"name":"Carla_0.9.7","slug":"Carla-0-9-7","link":"/tags/Carla-0-9-7/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"Entity","slug":"Entity","link":"/tags/Entity/"},{"name":"Springboot","slug":"Springboot","link":"/tags/Springboot/"},{"name":"chatting","slug":"chatting","link":"/tags/chatting/"},{"name":"채팅","slug":"채팅","link":"/tags/%EC%B1%84%ED%8C%85/"},{"name":"ORM","slug":"ORM","link":"/tags/ORM/"},{"name":"Hibernate","slug":"Hibernate","link":"/tags/Hibernate/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"스프링부트","slug":"스프링부트","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"Https","slug":"Https","link":"/tags/Https/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"배포","slug":"배포","link":"/tags/%EB%B0%B0%ED%8F%AC/"},{"name":"GCP","slug":"GCP","link":"/tags/GCP/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"잘 알려진 포트","slug":"잘-알려진-포트","link":"/tags/%EC%9E%98-%EC%95%8C%EB%A0%A4%EC%A7%84-%ED%8F%AC%ED%8A%B8/"},{"name":"포트","slug":"포트","link":"/tags/%ED%8F%AC%ED%8A%B8/"},{"name":"블루투스","slug":"블루투스","link":"/tags/%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/"},{"name":"Bluetooth","slug":"Bluetooth","link":"/tags/Bluetooth/"},{"name":"통신","slug":"통신","link":"/tags/%ED%86%B5%EC%8B%A0/"},{"name":"소켓","slug":"소켓","link":"/tags/%EC%86%8C%EC%BC%93/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"저전력","slug":"저전력","link":"/tags/%EC%A0%80%EC%A0%84%EB%A0%A5/"}],"categories":[{"name":"ex1","slug":"ex1","link":"/categories/ex1/"},{"name":"SpringBoot-JPA","slug":"SpringBoot-JPA","link":"/categories/SpringBoot-JPA/"},{"name":"Reactor-Pattern","slug":"Reactor-Pattern","link":"/categories/Reactor-Pattern/"},{"name":"ex1-1","slug":"ex1/ex1-1","link":"/categories/ex1/ex1-1/"},{"name":"java8(JDK1.8)","slug":"java8-JDK1-8","link":"/categories/java8-JDK1-8/"},{"name":"(Tutorial) Deploy-SpringBoot-Netty","slug":"Tutorial-Deploy-SpringBoot-Netty","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/"},{"name":"3 - Entity","slug":"SpringBoot-JPA/3-Entity","link":"/categories/SpringBoot-JPA/3-Entity/"},{"name":"java.NIO","slug":"Reactor-Pattern/java-NIO","link":"/categories/Reactor-Pattern/java-NIO/"},{"name":"1 - Hibernate","slug":"SpringBoot-JPA/1-Hibernate","link":"/categories/SpringBoot-JPA/1-Hibernate/"},{"name":"2 - SpringData-JPA","slug":"SpringBoot-JPA/2-SpringData-JPA","link":"/categories/SpringBoot-JPA/2-SpringData-JPA/"},{"name":"포트 목록","slug":"포트-목록","link":"/categories/%ED%8F%AC%ED%8A%B8-%EB%AA%A9%EB%A1%9D/"},{"name":"안드로이드 블루투스","slug":"안드로이드-블루투스","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/"},{"name":"Lambda Expression - 1","slug":"java8-JDK1-8/Lambda-Expression-1","link":"/categories/java8-JDK1-8/Lambda-Expression-1/"},{"name":"5 - SSL적용","slug":"Tutorial-Deploy-SpringBoot-Netty/5-SSL적용","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/5-SSL%EC%A0%81%EC%9A%A9/"},{"name":"2","slug":"Tutorial-Deploy-SpringBoot-Netty/2","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/2/"},{"name":"6","slug":"Tutorial-Deploy-SpringBoot-Netty/6","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/6/"},{"name":"4","slug":"Tutorial-Deploy-SpringBoot-Netty/4","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/4/"},{"name":"3","slug":"Tutorial-Deploy-SpringBoot-Netty/3","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/3/"},{"name":"1 - 기본배포","slug":"Tutorial-Deploy-SpringBoot-Netty/1-기본배포","link":"/categories/Tutorial-Deploy-SpringBoot-Netty/1-%EA%B8%B0%EB%B3%B8%EB%B0%B0%ED%8F%AC/"},{"name":"well-known port","slug":"포트-목록/well-known-port","link":"/categories/%ED%8F%AC%ED%8A%B8-%EB%AA%A9%EB%A1%9D/well-known-port/"},{"name":"Classic 통신","slug":"안드로이드-블루투스/Classic-통신","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/Classic-%ED%86%B5%EC%8B%A0/"},{"name":"BLE 통신","slug":"안드로이드-블루투스/BLE-통신","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/BLE-%ED%86%B5%EC%8B%A0/"}]}