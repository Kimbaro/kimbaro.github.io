{"pages":[],"posts":[{"title":"SpringBoot Netty 서버에 SSL 적용기 1","text":"개요본 포스팅 내용은 Google Cloud Platform의 가상머신을 통해 SpringBoot 프레임워크가 적용된 Web Application Server이며, 자신이 소유한 도메인이 있는 것으로 가정한다.이어서, 소유한 도메인을 자신의 가상컴퓨팅에 맵핑하는 과정을 정리했다. 설치가 되어 있다는 가정하에 진행한다. 준비 openSSL 라이브러리( sslforfree에서 제공해준 서명된 인증파일을 JavaKeyStore(jks)로 변환하기 위해 필요.) 도메인 ( https:// 접근을 위해 필요하다. ) 도베인적용DNS 영역 설정SpringBoot Netty서버 gradle환경에서 배포하기에서 배포한SpringBoot Netty서버에 자신의 도메인을 등록한다. 컴퓨팅환경은 Google Cloud Platform 을 통해 배포되었다.다음 예제에서 DNS와 연결할 컴퓨팅환경은 다음과 같다. 네트워크 서비스 - Cloud DNS - 영역만들기 영역이름 : 해당 DNS 영역의 이름 DNS이름 : 자신이 구매한 DNS의 이름 영역 세부정보DNS 도메인의 레코드를 설정한다. ‘레코드 모음 추가’를 선택한다. 기본적인 입력정보는 다음과 같다. A (Address Mapping records) : 도메인에 호스트의 IP주소(설정한외부IP)를 알려준다. 도메인과 IP주소의 맵핑작업이다.도메인주소 -&gt; IP주소 CNAME (Canonical Name) : 도메인을 따로 지정한 임의 도메인과 맵핑한다.임의도메인주소 -&gt; 도메인주소 NS (Name Server) : 해당 호스트의 공식 이름 서버이다. SOA (Start of Authority) : DNS서버의 설정정보가 담겨있다. DNS 네임서버 설정구매한 자신의 도메인의 네임서버를 설정한다.아래는 GoDaddy에서 구매한 도메인의 네임서버를 입력해 주는 장면이다. Google Cloud Platform의 자신의 DNS레코드에 생성된NS (Name Server)의 값을 모두 넣어준다. 앞에 ‘.’ 이 붙어있는데 이는 오류를 불러온다 지우자. DNS 레코드 맵핑 확인A (Address Mapping records)에 맵핑된 도메인정보와 IP주소가 올바른지 확인한다. 1nslookup 도메인주소 도메인 접속해보기 psGoddy를 통해 도메인을 구입했다. 해당 DNS 네임서버에 내 GCP서버의 갱신하는데 있어 약 10~15분 걸린거같다.","link":"/2019/07/29/SpringBoot-Netty-%EC%84%9C%EB%B2%84%EC%97%90-SSL-%EC%A0%81%EC%9A%A9%EA%B8%B0/"},{"title":"Lambda Expression 기초","text":"목차 기존 메서드와의 문법 비교 @Functional Interface java.util.function 패키지 JDK1.8 이 추가되면서 자바의 문법구조가 크게 변화하였다.기존 JAVA의 문법에 너무 익숙해져 있는 바람에 람다식을 구지 사용해야하나 라는 의문을 가지고 있었으나 익명함수 선언 과정에서 람다식은 코드의 구조를 매우 간결하게 만들어준다.JDK1.5에 추가된 Generics을 함께 사용하여 RxJava와 Spring5.0 이후 추가된 WebFlux를 이루는 ReactiveStream은 람다와 제네릭이 매우 중요하게 다뤄지는데 비동기 논블럭킹 방식의 앱을 구성하는데 있어 꼭 알아야할 기능이다. 기존 메서드와의 문법 비교+Lambda Expression에서 Lambda는 익명함수를, Expression은 식 이다. 이는 선언하고자하는 메서드의 선언을 익명으로 객체에 주입한다. 기존의 메서드 정의1234public int compare(int num1, int num2) { return num1 &gt; num2 ? num1 : num2; } 람다식 메서드 정의1(num1, num2) -&gt; num1 &gt; num2 ? num1 : num2; 람다식은 앞서 말한 듯 익명함수를 뜻한다 메서드 선언을 비교하니 기존의 ‘반환타입’ 과 ‘메서드명’ 이 제거되고매개변수의 타입 대신에 추론 가능한 변수명을 대입한다. 아래의 경우는 자바에서 선언한 메서드를 람다식으로 표현 한 경우의 ‘예’ 이다.람다식은 Functional Interface 항목에서 구현해본다. 기존 메서드 선언과 어떻게 다른지 비교만 해보자. 1234567public void printVar(String name, int age) { System.out.println(name + \"=\" + age); } ↓↓↓↓ (name, age) -&gt; System.out.println(name + \"|\" + age); 매개변수가 하나인 경우 ‘()괄호’ 생략 가능. 1234567891011121314151617 public int sumArr(int[] arr) { int sum = 0; for (int i : arr) { sum += i; } return sum; } ↓↓↓↓ arr -&gt; { int sum = 0; for (int i : arr) { sum += i; } return sum; }; 1234567public int roll() { return (int) (Math.random() * 6); } ↓↓↓↓ () -&gt; (int) (Math.random() * 6); 기존의 메서드 구성방식과 람다식의 방식을 비교해봤다. 람다의 익명함수는 지금껏 사용해온 익명객체선언과 동일하다. 익명객체선언123456new LambdaTest() { @Override public int roll() { return (int) (Math.random() * 6); } }; 익명함수선언1() -&gt; (int) (Math.random() * 6); @Functional Interface+Functional Interface는 람다식 호출을 위해 필요하며 interface에서 구현할 람다식의 추상메서드를 선언하고 해당 interface를 구현 할 객체에 선언해주면 된다.단, 익명객체를 익명함수인 람다로 대체하기 위해선 해당 메서드의 타입과 매개변수의 개수를동일하게 선언해야만 한다.아래의 예는 함수형 interface, LambdaTest를 정의한 것이다. 1234@FunctionalInterfaceinterface LambdaTest { public abstract String test(String data,int id);} 여기서 눈에 띄는 것은 @FunctionalInterface 애노테이션인데 이는 컴파일 과정에서 LambdaTest를 올바르게 구현했는지 여부를 확인해 준다. 해당 구현체를 선언한다면 다음과 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test { public Test() { } public Test(LambdaTest lambdaTest) { } public void testMethod(LambdaTest lambdaTest) { } public static void main(String[] args) { //익명함수객체주입 LambdaTest lambdaTest = (data, id) -&gt; { String str = data; int i = id; ... }; //익명함수생성자주입 Test test = new Test((data, id) -&gt; { String str = data; int i = id; ... }); //익명함수메서드주입 Test test = new Test(); test.testMethod((data, id) -&gt; { String str = data; int i = id; ... }); //기존의익명클래스객체주입 LambdaTest lambdaTest = new LambdaTest() { public String test(String data, int id) { ... return \"\"; } }; } } 람다식을 통한 선언방식은 위와같이 익명함수를 통한 방법, 생성자 매개변수 선언을 통한 방법, 메서드의 매개변수 선언을 통한 방법다음의 3가지 방법이 있다. 이 방식은 기존의 익명클래스 선언과 다르지 않고 동일하나 람다식을 통해 코드의 구성이 좀더 직관성을 이루며 간결해진다. List객체에 Lambda를 적용한 예토비스프링 강의참고 java.util.function 패키지+","link":"/2019/05/01/Lambda-Expression%EA%B8%B0%EC%B4%88/"},{"title":"SpringBoot Netty 서버에 SSL 적용기 2","text":"개요 이번장은 SSL (Secure Socket Layer) 인증서를 발급받고 이를 도메인이 적용된 서버에 적용하는 과정을 담았다.SSL은 Certificate Authority(CA)라 불리는 서드 파티로부터 서버와 클라이언트간에 정보교환에 있어 암호를 적용한 방식을 말한다. SSL 개념정리 무료 SSL (Secure Socket Layer) 인증서 발급받기인증서의 유효기간이 3개월로 짧은대신 무료이다.현재 DNS 주소와 연결된 서버의 도메인명을 입력해 준다. 이후 “Create Free SSL Certificate” 클릭한다.무료 SSL sslforfree“Manual Verification” -&gt; “Manually Verify Domain” “Automatic FTP Verification” - FTP 를 이용한 자동 처리 방식 “Manual Verification” - 소유권 인증 파일을 다운로드받아 직업 업로드 “Manual Verification” - DNS에 TXT 레코드로 소유권 인증 키를 추가 다음의 3가지의 발급 방식이 있는데, 본인은 “Manual Verification”을 사용하였다.도메인명을 입력하고 인증을 받기 위한 파일을 자신의 웹서버에 직접 업로드하여 인증파일을 발급받는다.인증파일은 “Manually Verify Domain” 클릭하여 진행한다. Download the following verification files by clicking on each link below 하위 목록“Download File #1” , “Download File #2”를 받은 후, Verify successful upload by visiting the following links in your browser아래의 경로를 생성하여 다운로드 파일을 업로드한다..well-known/acme-challenge/다운로드파일#1 , #2 자신의 프로젝트 아래에 resources 폴더에 위치하고있다. path등록이미지 클릭 시 확대Sample-Project에 Controller는 생성이 되어있다. 자신의 Spring-boot 프로젝트의 Controller에 해당 파일을 SSL인증 발급을 위해 경로를 설정해줘야한다. Sample-Project다운로드 1234567891011121314151617181920212223// import import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.core.io.Resource;import org.springframework.http.MediaType;import org.springframework.stereotype.Controller;import org.springframework.web.reactive.function.server.RouterFunction;import org.springframework.web.reactive.function.server.ServerResponse;import static org.springframework.web.reactive.function.server.RequestPredicates.GET;import static org.springframework.web.reactive.function.server.RouterFunctions.route;import static org.springframework.web.reactive.function.server.ServerResponse.ok;//class field @Bean public RouterFunction&lt;ServerResponse&gt; sslforfree1(@Value(&quot;classpath:/.well-known/acme-challenge/&lt;인증서파일이름&gt;&quot;) final Resource indexHtml) { return route(GET(&quot;/.well-known/acme-challenge/&lt;인증서파일이름&gt;&quot;), request -&gt; ok().contentType(MediaType.TEXT_PLAIN).syncBody(indexHtml)); } @Bean public RouterFunction&lt;ServerResponse&gt; sslforfree2(@Value(&quot;classpath:/.well-known/acme-challenge/&lt;인증서파일이름&gt;&quot;) final Resource indexHtml) { return route(GET(&quot;/.well-known/acme-challenge/&lt;인증서파일이름&gt;&quot;), request -&gt; ok().contentType(MediaType.TEXT_PLAIN).syncBody(indexHtml)); } http://URL 포트포워딩SSL 검증을 위해 사이트에서 보여준 주소는 http 형식의 80포트이다. 파일 path를 잡아줬다해도 해당 사이트에서 접근하는 경로에 유의하여80포트 접근 시 8080포트로 Redirect할 필요가 있다.(본인 환경에 따라 포트는 다를 수 있음.) 리눅스의 iptables를 활용해 규칙을 만들어준다.80 포트 -&gt; 8080포트로 Redirect 1iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 포트포워딩설정 확인 1iptables -t nat -L --line-numbers 잘못된 입력으로 인한 iptables 삭제 필요 시 1iptables -t nat -D PREROUTING &lt;해당하는리스트번호입력&gt; 규칙이 올바름에도 접속이 안될경우 자신의 GCP환경의 방화벽규칙을 확인한다. 또는 리눅스 환경에서 방화벽 접근 허용 확인 인증서 발급아래의 “Download SSL Certificate” 클릭인증서 생성이 완료되었다. “Download All SSL Certificate Files” 클릭하여 파일을 받는다. 위 이미지와 같이 3개의 파일이 있어야 한다. ca_bundle.crt certificate.crt private.key 인증서 조합이제 해당 인증서를 조합하여 하나의 아카이브로 만들어야한다. 1openssl pkcs12 -export -out 생성할파일명.pfx -inkey private.key -in certificate.crt -certfile ca_bundle.crt 생성된 pfx 형식의 파일이 있다 해당 파일이 https://URL 형식의 접근을 위한 인증서이다. 인증서 적용서버에 자신의 SNAPSHOT 파일이 위치한 경로에 pfx형식의 자신의 인증서를 저장한다. Spring-Boot의 설정파일인 Application.yml에 server의 내용을 수정한다. 12345678server: port: 8445 #SSL 사용할 포트 지정 ssl: enabled: true key-store: certificate_trco.pfx key-store-type: PKCS12 key-store-password: 123456 # pfx 생성 시 설정한 패스워드 # key-alias: trco.site # (필요시) Alias 명 지정. CSR 자동 생성시에는 CN 명 클라우드 플랫폼 방화벽 규칙 등록GCP에 사용할 SSL포트를 허용해준다. 테스트해보자. 8445 포트로 정상 실행 확인https://URL인증서내용 https://URL 포트포워딩기본적으로 도메인 접근 시 http로 접근하며 임의로 사용자가 https를 명시해야만 SSL접속을 시작하기 때문에 다음의 포트 규칙이 필요하다.해당 포스팅에서 사용된 포트는 8445임에 주의한다. 80포트 -&gt; 443포트(서버파일에서설정)1234567891011121314151617181920//사용자 환경에 따른 수정이 필요함.//가능하면 OS의 iptables 규칙 443포트 리다이렉션 포트 설정을 요함.private int http_port = 80;private int https_port = 443;@Beanpublic void startRedirectServer() { NettyReactiveWebServerFactory httpNettyReactiveWebServerFactory = new NettyReactiveWebServerFactory(http_port); httpNettyReactiveWebServerFactory.getWebServer((request, response) -&gt; { URI uri = request.getURI(); URI httpsUri; try { httpsUri = new URI(\"https\", uri.getUserInfo(), uri.getHost(), https_port, uri.getPath(), uri.getQuery(), uri.getFragment()); } catch (URISyntaxException e) { return Mono.error(e); } response.setStatusCode(HttpStatus.MOVED_PERMANENTLY); response.getHeaders().setLocation(httpsUri); return response.setComplete(); }).start();} 자신의 Spring-boot netty의 Controller에 위 코드를 명시한다.80포트 (http-default) -&gt; 443 (https-default) 443포트 -&gt; 8445포트(운영체제 iptables)12iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8445iptables -t nat -L -–line-numbers 조회해 보니 이전에 인증서 파일발급을 위해 지정했던 80-&gt;8080규칙이 존재한다. 해당 규칙은 1번 line에 위치함을 알 수 있다.(사용자마다 다르니 참고)1iptables -t nat -D PREROUTING (해당하는리스트번호입력) 해당하는 라인을 삭제 후 다시 조회해본다. iptables -t nat -L -–line-numbers 이후 서버를 실행해 접속해보자.서버에선 80포트와 8445포트를 사용하며 80포트, 즉 http로 접근한 경우 linux iptables 규칙이 아닌 서버단에서 80포트-&gt;8445포트로 Redirect한다.만일 443포트, 즉 https로 접근한 경우 linux iptables 규칙에 의해 Redirect된다. 결과https 접근 http 접근 참고 무료 SSL 보안 인증서 발급받기 (Free SSL Certificate) SSL 인증서 변환 가이드","link":"/2019/09/11/SpringBoot-Netty-%EC%84%9C%EB%B2%84%EC%97%90-SSL-%EC%A0%81%EC%9A%A9%EA%B8%B02/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 2","text":"개요이전 포스팅은 SpringBoot를 로컬환경에서 배포해봤다. 이번엔 GCP의 Cloud Compute에 리눅스를 베이스로 SpringBoot를 배포를 위한 GCP환경을 구성한다. 준비GCP의 가상머신 생성절차를 진행한다.컴퓨팅 - ComputeEngine - VM인스턴스 이후 아래의 이미지와 같이 본인이 원하는 서버를 구성하여 만들어줘야한다.여기서 본인은 아래 이미지와 같은 환경을 구성하였다. 이름 : 본인이 생성할 VM 인스턴스의 이름이다. 리전 : 가상머신을 실행할 서버의 위치이다. 머신구성 : 자신이 구성할 서버의 사양. 부팅디스크 : 서버를 구성할 OS. 방화벽 : 서버의 접근 방식이다. 초기 생성 시 적용할 프로토콜의 Default를 구성하는 값이다. 이제 해당 서버의 고정IP를 할당해준다.네트워킹 - VPC네트워크 - 외부 IP 주소 ‘유형=임시’ 를 ‘유형=고정’ 으로 변경해준다. ‘외부 접근허용을 위해’ 방화벽규칙을 적용한다.네트워킹 - VPC네트워크 - 방화벽 규칙 이름 : 본인이 생성할 방화벽 규칙의 이름이다. 우선순위 : 방화벽규칙에 적용될 우선순위이다. 사용환경에 따라 기본값을 달리하여 규칙을 적용할 수 있다. 대상 : 본인이 생성한 서버의 인스턴스를 대상으로 할것인지 여부를 묻는다. 소스 IP 범위 : 본인이 적용할 방화벽규칙의 IP 범위이다. 외부의 타 IP접근을 차단하거나 모두공개(0.0.0.0/0)할 수 있다. 프로토콜 및 포트 : 지정할 방화벽 규칙이다. 각 포트중 일부는 약속된 포트가 있으므로 개인의 포트를 적용할 땐 주의해야한다.다음 링크는 본인이 구성하는 기본 포트유형이다. 참고바란다.웹서버 기본 구성 포트 방화벽 규칙을 적용한 후 다음의 규칙이 적용되어 있어야한다. 8080 과 8443은 임의로 적용한 포트이며 각각 웹페이지 접근에 이용할 포트이다. ![](/images/SpringBoot-Netty서버-gradle-환경에서-배포하기2/5.png) GCP의 환경설정을 마무리하였다. 다음으로 외부에서 접근하기 위한 SSH키 생성 및 등록, 리눅스의 디렉토리 접근 권한을 변경해 FTP를 통해나의 VM에 파일을 전송한다.","link":"/2019/07/30/SpringBoot-Netty%EC%84%9C%EB%B2%84-gradle-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B02/"},{"title":"SpringBoot Netty서버 gradle환경에서 배포하기 4","text":"개요이전글에서 파일 배포까지 완료되었다 해당 파일을 실행하여 접속해보자 배포스프링서버 배포를 위해선 java가 설치되어 있어야 한다.해당 링크를 참고하여 설치하자 리눅스우분투자바설치 저장된 배포파일로 이동하여 다음의 커맨드를 입력한다.로그를 보면 8080 포트로 현재 서버가 실행 중 임을 알리고 있다. 1java -jar 배포파일.jar 접속해보자 자신의 ‘아이피주소:8080’ 형태의 주소로 이뤄져있다. nohup 적용ssh 터미널 종료 시 java -jar로 실행된 서버또한 종료되는데 해당 프로세스의 종료를 막기위해 nohup을 활용한다. - 쉘 스크립트 생성 및 실행nohup은 쉘 스크립트 파일을 실행한다. java -jar 명령어를 쉘 스크립트 파일에 입력해야한다. 1vim start-server.sh 자신의 .jar 배포파일을 입력해주자 생성된 쉘 스크립트를 실행한다. 1nohup ./start-server.sh 만일 Permission 문제가 발생한다면 쉘스크립트와 스냅샷 파일의 권한을 변경해보자 - 프로세스 동작 확인1netstat -lntp | grep 포트번호 - ps서버단에서의 System.out.println 같은 출력문은 ‘nohup.out’에 로그가 남으니 참고.","link":"/2019/09/02/SpringBoot-Netty%EC%84%9C%EB%B2%84-gradle%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B04/"},{"title":"SpringBoot Netty서버 gradle환경에서 배포하기 3","text":"개요이전 단계에서 GCP활용을 위해 OS이미지설치와 접근을 위한 환경설정을 마무리 하였다. 이번 단계에서 FTP접근과 배포를 위한 Spring SNAPSHOT을 가상컴퓨터환경에 배포해본다. SSH 공개키 생성운영체제 : OS X윈도우인 경우 - 윈도우 SSH키 생성 맥의 경우 ssh-keygen프로그램이 내장되어 있으므로 command에 ‘ssh-keygen’을 입력해보자 1ssh-keygen 임의의 경로인 ‘/Users/dongyounkim/Documents/Me/생성할파일명’에 생성하였다. 패스워드는 생성할때 미입력 시 이후 더이상 묻지 않는다. - 생성된 개인키와 공개키 - 커멘드 cat생성된 키 내용을 들여다 보자 1cat 생성한파일명.pub GCP 환경설정에 공개키 내용을 기입한다. - GCP SSH키메타데이터 - SSH키 - 수정/항목추가*복사한 값의 마지막을 ‘띄어쓰기’ 후 명칭을 따로 입력해줘야함을 잊지말자. FTP접속맥의 경우 ftp클라이언트가 내장되어있어 따로 프로그램을 설치할 필요가 없으나 내장된 ftp프로그램은 읽기만 가능하다.이에 본인은 FileZila를 활용하였다. FileZila 개인키 등록접속을 위해 개인키를 등록해준다.설정 - 연결 - SFTP - 키 파일 추가 접속본인의 GCP의 생성된 VM인스턴스를 참고한다.본인의 설정정보에 맞게 FTP클라이언트에 입력한다.GCP SSH키에 등록한 값의 명칭을 사용자명으로 사용한다.IANA에서 할당한 SSH 프로토콜의 포트 : 22 를 사용한다.본인의 가상컴퓨터에 접근이 완료되었다.이제 배포할때이다.배포파일은 이전 글에서 볼 수 있다. 이전글 바로가기 SSH접속 FTP를 통한 전송과정에 앞서 접근권한을 설정해준다.이를 위해선 SSH환경의 원격접속이 필요하다. 맥환경에선 내장된 접속 프로그램이 있어 쉽게 접근이 가능하다. FTP접속을 위해 생성해둔 자신의 키파일 경로로 이동해 다음의 커맨드를 입력해준다. 1ssh -i 자신개인키 사용자명@호스트주소 * FTP 접속할때의 자신의 입력정보를 참고해보자 자신의 Spring SNAPSHOT 배포파일을 저장할 디렉토리의 경로 권한을 수정해준다.본인은 다음의 경로에 파일을 관리하고자한다. 1/usr/games/ - 관리자 계정 패스워드설정1sudo passwd root - 관리자 계정 접속1su root - 경로 권한 확인12cd /usr/games/ls -la - 사용자 생성 및 그룹추가12345sudo useradd 사용자명sudo passwd 사용자명usermod -aG 그룹명 사용자명cat /etc/group ‘cd /home’ 경로로 이동해 생성한 사용자명을 확인하고 해당하는 그룹에 추가한다.‘cat /etc/group’ 추가한 자신의 계정이 정상적으로 추가되었는지 확인한다. - 그룹권한 변경자신이 배포할 경로의 권한여부를 확인 후 필요에 따라 변경해준다.여기선 /usr/games/의 경로를 다루므로 다음의 경로의 권한을 변경해준다. 123cd /usr/games/mkdir serverchmod 771 server/ 생성한 ‘server’명의 디렉터리의 접근권한 중 root그룹에 속한 계정에게 권한을 부여해준다","link":"/2019/09/02/SpringBoot-Netty%EC%84%9C%EB%B2%84-gradle%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B03/"},{"title":"SpringBoot Netty서버 gradle 환경에서 배포하기 1","text":"개요본 내용의 과정은 SpringBoot Netty를 gradle 환경에서 GCP Linux 서버에 배포하고 이후 SSL을 적용한https://kimbaro.github.io/categories/SpringBoot/SSL/ 까지의 내용을 담았다. 앞서…본인은 SpringBoot 2.0을 처음접하며 만난 non-blocking 방식의 webflux를함께 다뤄보았고 기존 blocking 방식의 jdbc를 벗어나 Reactive 에 내장되어 있는 mongodb-driver를 webflux와 함께 사용해 Reactive Microservice의 나만의 서버를 배포하려한다. 준비 localhost환경에서 동작 가능한 Gradle 환경의 SpringBoot-netty Sample-Project다운로드 배포용 snapshot을 생성한다.해당 프로젝트 폴더에 이동해 터미널에서 다음의 커맨드를 던져준다. 12./gradlew clean./gradlew build ./gradlew clean은 빌드전에 디렉토리와 그래들 환경을 초기화한다../gradlew build는 배포를 위한 snapshow을 생성한다. build/libs 아래에 (프로젝트명)-0.0.1-SNAPSHOT.jar 의 디렉토리와 jar 파일의 생성을 확인 할 수 있다.이제 해당 경로에서다음의 커맨드를 날려주자 이후 성공적으로 빌드가 되는지 여부를 확인해본다.로그는 다음과 같이 8080포트로 네티서버가 실행중임을 알 수 있다. 1java -jar (프로젝트명)-0.0.1-SNAPSHOT.jar 로컬환경에서 배포가 완료되었다면 다음으로 GCP을 활용해 Cloud Compute 환경에서 리눅스를 설치하고위와같이 배포하려한다.","link":"/2019/07/30/SpringBoot-gradle%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EC%9B%B9%EC%84%9C%EB%B2%84%EC%97%90-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/"},{"title":"Well-Known Port 정리","text":"0번 ~ 1023번 : 잘 알려진 포트(Well-Known Port)특정한 쓰임새를 위해서 IANA에서 할당한 TCP 및 UDP 포트 번호의 일부이다. 참고용 포트 TCP/UDP 설명 0 UDP 예약됨; 사용하지 않음 20 TCP FTP (파일 전송 프로토콜) - 데이터 포트 21 TCP FTP - 제어 포트 22 TCP SSH (Secure Shell) - ssh scp, sftp같은 프로토콜 및 포트 포워딩 53 TCP/UDP DNS (Domain Name System) 80 TCP/UDP HTTP (HyperText Transfer Protocol) - 웹 페이지 전송 443 TCP HTTPS - SSL 위의 HTTP (암호화 전송)","link":"/2019/08/05/Well-Known-Port-%EC%A0%95%EB%A6%AC/"},{"title":"안드로이드 Classic 통신","text":"개요안드로이드 Classic통신은 블루투스 3.0 이하의 버전을 말하며, 블루투스 4.0 이상은 BLE통신을 뜻한다.블루투스 4.0이상의 모듈은 그 하위 버전을 포함하기도한다. 여기서 알아볼 것은 Classic한 블루투스 통신인 Socket통신이다.안드로이드는 Android Bluetooth API를 통해 블루투스 기능에 관한 엑세스 권한을 제공한다. 이 글에서 제공하는 내용은 아래와 같은 과정의 Sample Project이다 페어링된 블루투스 기기에 대한 로컬 블루투스 어댑터 쿼리 RFCOMM 채널 설정 블루투스 기기의 데이터 수신 블루투스에 관한 자세한 정보는 Document를 참고하자.https://developer.android.com/guide/topics/connectivity/bluetooth?hl=ko 해당 내용에 따른 Sample Project는 다음과 같다.https://github.com/Kimbaro/android-BluetoothClassicProtocol-Sample Pre-requisites 이름 버전 설명 Android SDK 28 - Android Build Tools v28.0.0 - 리뷰블루투스 기능 사용을 위한 권한은 다음과 같다. 123456789&lt;manifest&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; 이하내용생략 . . . 패키지 구조블루투스체크 -&gt; 기기연결 과정을 두 클래스로 나눠 진행하고 디바이스정보를 담고있는 Device클래스를 포함한다.util.BT_check , util.BT_connect , util.Device util.BT_check인스턴스를 불러오는 방법은 간단하다. 사용자가 위치한 activity , 블루투스 수신받은 데이터를 보여주기 위한 textView,상황에 따라 textView를 다른 아이템으로 바꿔 사용 할 수 있겠다. 여기서 BT_check 클래스는 그 activity와 textView를 인자로 전달받아 초기화한다. 12345678910111213141516171819public class MainActivity extends AppCompatActivity {Button button = null; TextView textView = null; Activity activity = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); activity = this; button = findViewById(R.id.bt1); textView = findViewById(R.id.tv1); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { BT_check bt_check = new BT_check(activity, textView); bt_check.checkBluetooth(); util.BT_check.checkBluetooth()블루투스 소켓 통신을 위한 메서드이며 블루투스의 전체적인 정보가 담긴 어댑터인 BluetoothAdapter를 생성하고정상적으로 블루투스가 동작하는지 통신하기전 기기를 체크한다. 123456789101112131415161718192021222324public class BT_check { private BluetoothAdapter mBluetoothAdapter = null; private Activity activity = null; private TextView textView; public void checkBluetooth() { mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (mBluetoothAdapter == null) { // 장치가 블루투스 지원하지 않는 경우 Toast.makeText(activity.getApplicationContext(), \"해당 모바일은 블루투스를 지원하지 않음\", Toast.LENGTH_SHORT).show(); } else { // 장치가 블루투스 지원하는 경우 if (!mBluetoothAdapter.isEnabled()) { // 블루투스를 지원하지만 비활성 상태인 경우 // 블루투스를 활성 상태로 바꾸기 위해 사용자 동의 요첨 Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); activity.startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); } else { // 블루투스를 지원하며 활성 상태인 경우 // 페어링된 기기 목록을 보여주고 연결할 장치를 선택. selectDevice(); } } } util.BT_check.selectDevice()페어링된 기기목록을 보여주고 연결할 장치를 선택한다. 해당 페어링 목록은 두 기기간의 연결프로세스가 성립되어 또는 성립된적이 있어서 언제든 사용할 수 있도록 디바이스가 캐싱해둔 페어링 목록을 뜻한다. 목록은 AlertDialog를 통해 띄워준다.만일 사용자가 페어링 기기를 찾아 선택했다면 블루투스디바이스와의 연결을 위한 BT_connect.class를 호출한다 해당 객체의 생성자는 다음의 인자를 받아 초기화한다.** 사용자가 위치한 액티비티, 검색된 블루투스목록, 블루투스어댑터 , 데이터가입력될 textView ** 결과적으로 BT_check.class에서 얻어온 정보를 BT_connect.class로 전달한다고 보면 된다. 12345678910111213141516171819202122232425262728293031323334353637383940Set&lt;BluetoothDevice&gt; mDevices; int mPairedDeviceCount; private void selectDevice() { //페어링되었던 기기 목록 획득 mDevices = mBluetoothAdapter.getBondedDevices(); //페어링되었던 기기 갯수 mPairedDeviceCount = mDevices.size(); //Alertdialog 생성(activity에는 context입력) AlertDialog.Builder builder = new AlertDialog.Builder(activity); //AlertDialog 제목 설정 builder.setTitle(\"등록된 디바이스\"); 이하내용생략 . . . builder.setItems(items, new DialogInterface.OnClickListener() { // 리스트 아이템 클릭 이벤트 @Override public void onClick(DialogInterface dialog, int which) { Dialog dialog_ = (Dialog) dialog; // 연결할 장치를 선택하지 않고 '취소'를 누른 경우 if (which == listItems.size() - 1) { Toast.makeText(dialog_.getContext(), \"취소\", Toast.LENGTH_SHORT).show(); } else { //취소가 아닌 디바이스를 선택한 경우 해당 영역 실행 Toast.makeText(dialog_.getContext(), \"선택 장치명 : \" + items[which].toString(), Toast.LENGTH_SHORT).show(); setDeviceName(items[which].toString()); //타겟 액티비티 ,블루투스 검색 목록 , 검증된 블루투스 정보, 받아온 값 입력대상 BT_connect bt_connect = new BT_connect(activity, getMDevices(), getMBluetoothAdapter(), textView); //본인이 선택한 블루투스이름 bt_connect.connectToSelectedDevice(getDeviceName()); } } }); util.BT_connect모든 준비가 끝났다. BT_check.class에서 생성된 데이터로 BT_connect.class가 구성되어있다. 그 외에도 소켓통신 및 이를 위한 스트림 객체등통신 및 데이터를 처리하기위한 객체가 선언되어있다. 1234567891011121314151617181920212223242526272829303132public class BT_connect { BluetoothSocket mSocket; InputStream mInputStream; OutputStream mOutputStream; Activity activity; BluetoothDevice mRemoteDevice; Set&lt;BluetoothDevice&gt; mDevices; BluetoothAdapter mBluetoothAdapter; byte[] readBuffer; //수신 데이터 int readBufferPositon; //버퍼 내 수신 문자 저장 위치 Thread mWorkerThread; byte mDelimiter = 10; private BT_connect() { } //데이터 출력 테스트용 TextView textView; Button button; public BT_connect(Activity activity, Set&lt;BluetoothDevice&gt; mDevices, BluetoothAdapter mBluetoothAdapter, TextView textView) { this.activity = activity; this.mDevices = mDevices; this.mBluetoothAdapter = mBluetoothAdapter; this.textView = textView; button = this.activity.findViewById(R.id.bt1); } 이하내용생략 . . . util.BT_connect.connectToSelectedDevice()블루투스 데이터를 실시간으로 받기위해선 스레드가 필요하다. 스트림 객체는 Handler를 통해 생성하며 BluetoothSocket.getOutputStream() , BluetoothSocket.getInputStream() 두 메서드 선언으로 스트림이 연결된다.소켓 Connect 상황에 따라 Handler에 다음의 값을 보내 상황에 따른 이벤트가 발생한다. 1인 경우 연결에 성공하여 스트림을 생성하는 단계 -1인 경우 연결에 오류가 있어 소켓을 close하는 단계 연결에 성공한 경우 데이터 수신을 처리하는 beginListenForData()를 실행한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859...위내용생략 public void connectToSelectedDevice(final String selectedDeviceName) { button.setText(\"연결중 기다려주세요\"); //handler는 thread에서 던지는 메세지를 보고 다음 동작을 수행시킨다. final Handler mHandler = new Handler() { public void handleMessage(Message msg) { if (msg.what == 1) // 연결 성공 { try { //블루투스 기기와의 소켓통신을 위한 커넥션 실행 mOutputStream = mSocket.getOutputStream(); mInputStream = mSocket.getInputStream(); // 데이터 수신 리스너 beginListenForData(); button.setText(\"연결 성공\"); } catch (IOException e) { e.printStackTrace(); } } else { //연결 실패 Toast.makeText(activity, \"연결실패! 연결상태를 확인해주세요\", Toast.LENGTH_SHORT).show(); try { mSocket.close(); button.setText(\"연결 실패\"); } catch (IOException e) { e.printStackTrace(); } } } }; //연결과정을 수행할 thread 생성 Thread thread = new Thread(new Runnable() { public void run() { //선택된 기기의 이름을 갖는 bluetooth device의 object mRemoteDevice = getDeviceFromBondedList(selectedDeviceName); UUID uuid = Device.DEVICE_UUID; try { // 소켓 생성 mSocket = mRemoteDevice.createRfcommSocketToServiceRecord(uuid); // RFCOMM 채널을 통한 연결, socket에 connect하는데 시간이 걸린다. 따라서 ui에 영향을 주지 않기 위해서는 // Thread로 연결 과정을 수행해야 한다. mSocket.connect(); mHandler.sendEmptyMessage(1); } catch (Exception e) { // 블루투스 연결 중 오류 발생 mHandler.sendEmptyMessage(-1); } } }); //연결 thread를 수행한다 thread.start(); } util.BT_connect.beginListenForData()블루투스 커넥션을 위한 해당 스레드과정에서, beginListenForData()에서 데이터를 받아 처리하기 위한 스레드가 한번더 실행된다.Queue방식으로 블루투스기기로 부터 데이터를 수신하여 handler.post에서 데이터 처리 이벤트를 진행한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//블루투스 수신 리스너 protected void beginListenForData() { final Handler handler = new Handler(); readBuffer = new byte[1024]; readBufferPositon = 0; mWorkerThread = new Thread(new Runnable() { @Override public void run() { while (!Thread.currentThread().isInterrupted()) { try { int bytesAvailable = mInputStream.available(); if (bytesAvailable &gt; 0) { //데이터가 수신된 경우 byte[] packetBytes = new byte[bytesAvailable]; mInputStream.read(packetBytes); for (int i = 0; i &lt; bytesAvailable; i++) { byte b = packetBytes[i]; if (b == mDelimiter) { byte[] encodedBytes = new byte[readBufferPositon]; System.arraycopy(readBuffer, 0, encodedBytes, 0, encodedBytes.length); final String data = new String(encodedBytes, \"US-ASCII\"); readBufferPositon = 0; handler.post(new Runnable() { public void run() { //===== 데이터 정상 수신 영역 ===== //수신된 데이터는 data변수에 의해 String형 변환되어 있음. textView.setText(data); } }); } else { readBuffer[readBufferPositon++] = b; } } } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } }); //데이터 수신 thread 시작 mWorkerThread.start(); }} 마무리해당 통신과정은 위에서 언급했듯이 Classic한 통신방법으로 기존 블루투스 3.0방식의 모듈에서 많이 활용된다.모바일에서의 동작에 있어 안드로이드 버전에 따른 여러 제약사항이 BLE에 비해 크게 변경된 사항은 없다. 그냥 돌아다니는거 써도 될 정도로.. 인턴십때문에 현장에서 스마트밴드와 호흡기측정기를 블루투스통신 하는 과정이 있었는데 덕분에 BLE와 Socket통신을 실제업무에서 적용해 볼 수 있는 기회라 참 재밌었다.","link":"/2019/09/05/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-Socket%ED%86%B5%EC%8B%A0/"},{"title":"안드로이드 BLE 통신","text":"개요구글이 깃에 올려둔 Sample project 중에서 블루투스 BLE의 코드는 API21 이상의 버전과 호완성 문제를 보인다.타겟을 21로 낮추면 되겠지만 앱을 플레이스토어에 배포하기 위해선 정책이 바뀌어 API28(Android Pie)이상을 타겟으로 잡아야한다.이로인한 문제는 다음과 같고 필수적으로 변경시켜야한다. BluetoothAdapter 클래스의 stopLeScan 과 startLeScan 을 지원하지 않는다.BluetoothLeScanner 클래스를 사용한 stopScan, startScan 두 메서드를 사용해야한다. 블루투스 통신에 있어서 위치권한과 GPS를 함께 사용한다.갤럭시S8 기기에서 테스트 했었는데, 위치권한 뿐 아니라 GPS가 켜있어야 함을 알 수 있었다.https://stackoverflow.com/questions/33043582/bluetooth-low-energy-startscan-on-android-6-0-does-not-find-devices/33045489#33045489 구글이 제공한 기존의 샘플은 다음과 같다.https://github.com/googlesamples/android-BluetoothLeGatt.git 위 문제에 따른 수정본은 다음과 같다.https://github.com/Kimbaro/android-BluetoothLeGatt-API28.git Pre-requisites 이름 버전 설명 Android SDK 28 - Android Build Tools v28.0.3 - 리뷰변경점, BluetoothLeScanner 관련BluetoothAdapter클래스를 대신해 BluetoothLeScanner를 추가 12345678910111213141516private LeDeviceListAdapter mLeDeviceListAdapter; private boolean mScanning; private Handler mHandler; //추가 API21 이상부터 스캔을 위해선 다음의 클래스 사용 private BluetoothLeScanner mBLEScanner; private BluetoothAdapter mBluetoothAdapter; private static final int REQUEST_ENABLE_BT = 1; private static final int MY_PERMISSIONS_REQUEST = 2; 이하내용생략 . . . BluetoothAdapter의 스캔기능은 사용하지 않으나 Adapter 본연의 역할은 수행하고 있다.onCreate()에서 BluetoothManager의 정보를 getAdapter()를 선언하여 BluetoothAdapter에 제공하고 이 블루투스 정보를 BluetoothLeScanner 객체에 전달하고 있다. 결론으로 전체적인 흐름은 다음과 같다.*BluetoothManager =&gt; BluetoothAdapter =&gt; BluetoothLeScanner =&gt; 스캔기능 수행 * 12345678910111213141516171819202122232425262728private BluetoothLeScanner mBLEScanner;private BluetoothAdapter mBluetoothAdapter;@Override public void onCreate(Bundle savedInstanceState) { . . . 위내용생략 final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = bluetoothManager.getAdapter(); // Checks if Bluetooth is supported on the device. if (mBluetoothAdapter == null) { Toast.makeText(this, R.string.error_bluetooth_not_supported, Toast.LENGTH_SHORT).show(); finish(); return; } //추가 mBLEScanner = mBluetoothAdapter.getBluetoothLeScanner(); // Checks if Bluetooth LE Scanner is available. if (mBLEScanner == null) { Toast.makeText(this, \"Can not find BLE Scanner\", Toast.LENGTH_SHORT).show(); finish(); return; } } 변경점, BLE통신 콜백 클래스 변경BluetoothAdapter의 스캔기능이 지원되지 않으면서 그에따라 BluetoothAdapter.LeScanCallback 또한 사용하지 않는다.LeScanCallback은 interface로 단독적으로 오버라이딩하였으나 BluetoothLeScanner에 사용되는 콜백클래스인 ScanCallback은 Object를 상속받는 abstract 추상객체로 이뤄져있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 private ScanCallback mScanCallback = new ScanCallback() { @Override public void onScanResult(int callbackType, ScanResult result) { super.onScanResult(callbackType, result); processResult(result); } @Override public void onBatchScanResults(List&lt;ScanResult&gt; results) { super.onBatchScanResults(results); for (ScanResult result : results) { processResult(result); } } @Override public void onScanFailed(int errorCode) { super.onScanFailed(errorCode); } private void processResult(final ScanResult result) { runOnUiThread(new Runnable() { @Override public void run() { mLeDeviceListAdapter.addDevice(result.getDevice()); mLeDeviceListAdapter.notifyDataSetChanged(); } }); } }; // 사용하지 않음.// private BluetoothAdapter.LeScanCallback mLeScanCallback =// new BluetoothAdapter.LeScanCallback() {//// @Override// public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {// runOnUiThread(new Runnable() {// @Override// public void run() {// mLeDeviceListAdapter.addDevice(device);// mLeDeviceListAdapter.notifyDataSetChanged();// }// });// }// }; 추가, GPS의 사용블루투스 기능을 사용하기 위해선 위치권한 허용 뿐만 아니라 해당 GPS가 켜있어야한다. 그렇지 않으면 기능사용이 불가하므로 이를 방지한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//AlertDialog private void alertCheckGPS() { AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage(\"GPS를 허용해 주셔야 앱 이용이 가능합니다.\") .setCancelable(false) .setPositiveButton(\"GPS 설정\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { moveConfigGPS(); } }) .setNegativeButton(\"취소\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { dialog.cancel(); restart(); } }); AlertDialog alert = builder.create(); alert.show(); } // GPS 설정화면으로 이동 private void moveConfigGPS() { Intent gpsOptionsIntent = new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS); startActivityForResult(gpsOptionsIntent, MY_PERMISSIONS_REQUEST); } //재시작 public void restart(){ Intent i = getBaseContext().getPackageManager(). getLaunchIntentForPackage(getBaseContext().getPackageName()); i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(i); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { // User chose not to enable Bluetooth. if (requestCode == REQUEST_ENABLE_BT &amp;&amp; resultCode == Activity.RESULT_CANCELED) { finish(); return; } if (requestCode == MY_PERMISSIONS_REQUEST) { if (!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) { Toast.makeText(getApplicationContext(), \"GPS가 꺼져있습니다.\", Toast.LENGTH_LONG).show(); //앱 재실행 restart(); } } super.onActivityResult(requestCode, resultCode, data); }@Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getActionBar().setTitle(R.string.title_devices); locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); //버전체크 if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) || (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED)) { ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, MY_PERMISSIONS_REQUEST); } //GPS 설정여부 if(!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)){ alertCheckGPS(); } 이하내용생략 . . . 마무리안드로이드 API23을 타겟으로 앱 개발했다가 큰 낭패를 보았다. 막상 만들꺼 다 만들어놓고 배포하자니 API28이상만 배포 가능하다고하니..삽질을 많이 해버렸다.","link":"/2019/09/02/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-BLE-%ED%86%B5%EC%8B%A0/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"스프링부트","slug":"스프링부트","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/"},{"name":"Https","slug":"Https","link":"/tags/Https/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"배포","slug":"배포","link":"/tags/%EB%B0%B0%ED%8F%AC/"},{"name":"GCP","slug":"GCP","link":"/tags/GCP/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"잘 알려진 포트","slug":"잘-알려진-포트","link":"/tags/%EC%9E%98-%EC%95%8C%EB%A0%A4%EC%A7%84-%ED%8F%AC%ED%8A%B8/"},{"name":"포트","slug":"포트","link":"/tags/%ED%8F%AC%ED%8A%B8/"},{"name":"블루투스","slug":"블루투스","link":"/tags/%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/"},{"name":"Bluetooth","slug":"Bluetooth","link":"/tags/Bluetooth/"},{"name":"통신","slug":"통신","link":"/tags/%ED%86%B5%EC%8B%A0/"},{"name":"소켓","slug":"소켓","link":"/tags/%EC%86%8C%EC%BC%93/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"저전력","slug":"저전력","link":"/tags/%EC%A0%80%EC%A0%84%EB%A0%A5/"}],"categories":[{"name":"SpringBoot-Netty / build.gradle","slug":"SpringBoot-Netty-build-gradle","link":"/categories/SpringBoot-Netty-build-gradle/"},{"name":"java8(JDK1.8)","slug":"java8-JDK1-8","link":"/categories/java8-JDK1-8/"},{"name":"2","slug":"SpringBoot-Netty-build-gradle/2","link":"/categories/SpringBoot-Netty-build-gradle/2/"},{"name":"5 - SSL적용","slug":"SpringBoot-Netty-build-gradle/5-SSL적용","link":"/categories/SpringBoot-Netty-build-gradle/5-SSL%EC%A0%81%EC%9A%A9/"},{"name":"4","slug":"SpringBoot-Netty-build-gradle/4","link":"/categories/SpringBoot-Netty-build-gradle/4/"},{"name":"3","slug":"SpringBoot-Netty-build-gradle/3","link":"/categories/SpringBoot-Netty-build-gradle/3/"},{"name":"Lambda Expression - 1","slug":"java8-JDK1-8/Lambda-Expression-1","link":"/categories/java8-JDK1-8/Lambda-Expression-1/"},{"name":"1 - 기본배포","slug":"SpringBoot-Netty-build-gradle/1-기본배포","link":"/categories/SpringBoot-Netty-build-gradle/1-%EA%B8%B0%EB%B3%B8%EB%B0%B0%ED%8F%AC/"},{"name":"포트 목록","slug":"포트-목록","link":"/categories/%ED%8F%AC%ED%8A%B8-%EB%AA%A9%EB%A1%9D/"},{"name":"6","slug":"SpringBoot-Netty-build-gradle/6","link":"/categories/SpringBoot-Netty-build-gradle/6/"},{"name":"안드로이드 블루투스","slug":"안드로이드-블루투스","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/"},{"name":"well-known port","slug":"포트-목록/well-known-port","link":"/categories/%ED%8F%AC%ED%8A%B8-%EB%AA%A9%EB%A1%9D/well-known-port/"},{"name":"Classic 통신","slug":"안드로이드-블루투스/Classic-통신","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/Classic-%ED%86%B5%EC%8B%A0/"},{"name":"BLE 통신","slug":"안드로이드-블루투스/BLE-통신","link":"/categories/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4/BLE-%ED%86%B5%EC%8B%A0/"}]}